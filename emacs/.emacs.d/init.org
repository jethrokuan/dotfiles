#+TITLE: Jethro's Emacs.d Configuration
* Introduction
* Basic Setup
** Add MELPA and Org Repository
   Add package archives. Note that I'm using HTTP, HTTPS did not work for me. To configure HTTPS, simply replace occurrences of http with https.

   #+BEGIN_SRC emacs-lisp :tangle yes
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (package-initialize))
   #+END_SRC

** Add [[https://github.com/jwiegley/use-package/issues/70][use-package]]
   Use-package allows for isolation of package configuration, while maintaining tidiness and performance.

   #+BEGIN_SRC emacs-lisp :tangle yes
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-and-compile
  (defvar use-package-verbose t) 
  (require 'cl)
  (require 'use-package)
  (require 'bind-key)
  (require 'diminish)
  (setq use-package-always-ensure t))
   #+END_SRC

** Add validate
   Validate is a package that checks for and reports Emacs config errors.
   #+begin_src emacs-lisp :tangle yes
  (use-package validate
    :demand t)
   #+end_src
** User configuration
** 
   #+begin_src emacs-lisp :tangle yes
(setq user-full-name "Jethro Kuan"
      user-mail-address "jethrokuan95@gmail.com")
   #+end_src

** Custom file
   #+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
   #+END_SRC
** Default browser
   #+begin_src emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-firefox
        browse-url-new-window-flag  t
        browse-url-firefox-new-window-is-tab t)
   #+end_src
** Custom font
   I use Hack, patched with Powerline. Other good alternatives include Source Code Pro.
*** Source Code Pro
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'initial-frame-alist
                   '(font . "Iosevka-12"))
      (add-to-list 'default-frame-alist
                   '(font . "Iosevka-12"))
    #+END_SRC

** UI Cruft
   Remove useless toolbars and splash screens.

   #+begin_src emacs-lisp :tangle yes
(tooltip-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
   #+end_src

** Use y/n over yes/no
   Always prefer the shorter y/n over yes/no.

   #+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Replace region when typing
   Type over a selected region, instead of deleting before typing.

   #+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode +1)
   #+end_src

** Sentences
   Emacs uses double-spaces by default. Use single spaces by default:

   #+BEGIN_QUOTE
   NOTE: This will cause an indistinction between sentences and name abbrieviations (eg. E. B. White)
   #+END_QUOTE

   #+begin_src emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
   #+end_src

** Tab with 2 spaces
   #+begin_src emacs-lisp :tangle yes
(setq-default tab-width 2)
(setq-default js-indent-level 2)
(setq-default indent-tabs-mode nil)
   #+end_src

** Don't wrap lines
   Don't wrap lines for coding. Create a hook that enables wrapping, for modes like org-mode and markdown-mode.

   #+begin_src emacs-lisp :tangle yes
(setq-default truncate-lines t)
(defun trunc-lines-hook ()
  (setq truncate-lines nil))
   #+end_src

** Backup directory
   #+begin_src emacs-lisp :tangle yes
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
   #+end_src

   The following code will delete all backup files that are older than a certain date:

   #+begin_src emacs-lisp :tangle no
(message "Deleting old backup files...")
(let ((week (* 60 60 24 7))
      (current (float-time (current-time))))
  (dolist (file (directory-files temporary-file-directory t))
    (when (and (backup-file-name-p file)
               (> (- current (float-time (fifth (file-attributes file))))
                  week))
      (message "%s" file)
      (delete-file file))))
   #+end_src
** Load secrets
   #+begin_src emacs-lisp :tangle yes
(load "~/.emacs.d/secrets.el" t)
   #+end_src
** Add PATH to eshell
   #+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell 
    :config
    (exec-path-from-shell-initialize))
   #+end_src

** Default shell
   #+begin_src emacs-lisp :tangle yes
  (setq-default explicit-shell-file-name "/bin/bash")
  (setq-default shell-file-name "/bin/bash")
   #+end_src
** Theme
*** Adwaita
    #+BEGIN_SRC emacs-lisp :tangle no
  (load-theme 'adwaita t)
    #+END_SRC
*** Zenburn Theme
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package zenburn-theme
    :init
    (load-theme 'zenburn t))
    #+END_SRC
** Keybindings
*** Opening Lines
    #+begin_src emacs-lisp :tangle yes
  (defun open-next-line (arg)
    "Move to the next line and then opens a line.
     See also `newline-and-indent'."
    (interactive "p")
    (end-of-line)
    (open-line arg)
    (next-line 1)
    (when 'newline-and-indent
      (indent-according-to-mode)))

  (defun open-previous-line (arg)
    "Open a new line before the current one. 
       See also `newline-and-indent'."
    (interactive "p")
    (beginning-of-line)
    (open-line arg)
    (when 'newline-and-indent
      (indent-according-to-mode)))

  (bind-key* "C-o" 'open-next-line)
  (bind-key* "M-o" 'open-previous-line)
    #+end_src
*** Nuke all buffers with =C-c !=
    #+begin_src emacs-lisp :tangle yes
  (defun jethro/nuke-all-buffers ()
    (interactive)
    (mapcar 'kill-buffer (buffer-list))
    (delete-other-windows))

  (bind-key* "C-c !" 'jethro/nuke-all-buffers)
    #+end_src
*** eshell with =C-x m=
    #+begin_src emacs-lisp :tangle yes
  (bind-key* "C-x m" 'eshell)
    #+end_src
*** mark-paragraph with =M-p=
    #+begin_src emacs-lisp :tangle yes
  (bind-key* "M-p" 'mark-paragraph)
    #+end_src
*** compile with =<f9>=
    #+begin_src emacs-lisp :tangle yes
  (bind-key* "<f9>" (lambda ()
                      (interactive)
                      (setq-local compilation-read-command nil)
                      (call-interactively 'compile)))
    #+end_src
**** 
** Hydra
   #+begin_src emacs-lisp :tangle yes
  (use-package hydra)
   #+end_src
*** Ample Theme
    #+BEGIN_SRC emacs-lisp :tangle no
  (use-package ample-theme
    :init
    (load-theme 'ample t))
    #+END_SRC
* Mail (notmuch)
** Basic Setup
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package notmuch
    :bind (("<f10>" . notmuch))
    :config
    (define-key notmuch-search-mode-map "R"
    (lambda ()
      "mark message as read"
      (interactive)
      (notmuch-search-tag '("-unread")))))
   #+END_SRC
** Goobook
   #+BEGIN_SRC emacs-lisp :tangle yes
  (require 'notmuch-address)
  (setq notmuch-address-command "~/.emacs.d/goobook")
  (notmuch-address-message-insinuate)
   #+END_SRC
* Ivy
  I've recently switched over from =helm= to =ivy=. Ivy is simpler, and easier to extend.
** flx
   Flx is required for fuzzy-matching.
   #+begin_src emacs-lisp :tangle yes
(use-package flx)
   #+end_src
** Counsel
   Counsel contains ivy enhancements for commonly-used functions.
   #+begin_src emacs-lisp :tangle yes
  (use-package counsel
    :demand t
    :bind*
    (("C-c C-r" . ivy-resume)
     ("M-a" . counsel-M-x)
     ("C-M-i" . counsel-imenu)
     ("C-x C-f" . counsel-find-file)
     ("C-x j" . counsel-dired-jump)
     ("C-x l" . counsel-locate)
     ("C-c j" . counsel-git-grep)
     ("C-c k" . counsel-rg)
     ("M-y" . counsel-yank-pop))
    :bind (:map help-map
                ("f" . counsel-describe-function)
                ("v" . counsel-describe-variable)
                ("l" . counsel-info-lookup-symbol))
    :config
    (ivy-mode 1)
    (setq counsel-find-file-at-point t)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (setq ivy-initial-inputs-alist nil)
    (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done))
   #+end_src
** Swiper
   Swiper is ivy-enhanced isearch.
   #+begin_src emacs-lisp :tangle no
  (use-package swiper
    :bind*
    (("C-s" . swiper)
     ("C-r" . swiper)
     ("C-M-s" . swiper-all))
    :bind
    (:map read-expression-map
          ("C-r" . counsel-expression-history)))
   #+end_src
** Fuzzy Searching
   #+begin_src emacs-lisp :tangle yes
  (setq ivy-re-builders-alist
        '((ivy-switch-buffer . ivy--regex-plus)
          (swiper . ivy--regex-plus)
          (t . ivy--regex-fuzzy)))
   #+end_src
** Ivy custom actions
   #+begin_src emacs-lisp :tangle yes
  (define-key ivy-minibuffer-map (kbd "C-:") 'ivy-dired)
  (define-key ivy-minibuffer-map (kbd "C-c o") 'ivy-occur)
  (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
  (ivy-set-actions
   t
   '(("I" insert "insert")))
   #+end_src
*** Ivy-dired
    #+begin_src emacs-lisp :tangle yes
  (defun ivy-dired ()
    (interactive)
    (if ivy--directory
        (ivy-quit-and-run
         (dired ivy--directory)
         (when (re-search-forward
                (regexp-quote
                 (substring ivy--current 0 -1)) nil t)
           (goto-char (match-beginning 0))))
      (user-error
       "Not completing files currently")))

  (define-key ivy-minibuffer-map (kbd "C-:") 'ivy-dired)
    #+end_src 
* Moving Around
** Crux
   #+begin_src emacs-lisp :tangle yes
  (use-package crux 
    :bind* (("C-c o" . crux-open-with)
            ("C-c n" . crux-cleanup-buffer-or-region)
            ("C-c D" . crux-delete-file-and-buffer)
            ("C-a" . crux-move-beginning-of-line)
            ("M-o" . crux-smart-open-line)
            ("C-c r" . crux-rename-file-and-buffer)
            ("M-d" . crux-duplicate-current-line-or-region)
            ("M-D" . crux-duplicate-and-comment-current-line-or-region)
            ("s-o" . crux-smart-open-line-above)))
   #+end_src
** Open file
   #+BEGIN_SRC emacs-lisp :tangle yes
  (defun jethro/open-in-external-app ()
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference."
    (interactive)
    (let* (
           (-file-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name))))
           (-do-it-p (if (<= (length -file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))
      (when -do-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (-fpath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" -fpath t t))) -file-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (-fpath)
             (shell-command
              (concat "open " (shell-quote-argument -fpath))))  -file-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (-fpath) (let ((process-connection-type nil))
                              (start-process "" nil "xdg-open" -fpath))) -file-list))))))
  (bind-key* "<f8>" 'jethro/open-in-external-app)
   #+END_SRC
** Anzu
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package anzu
    :diminish anzu-mode 
    :config
    (global-anzu-mode +1)
    (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
    (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp))
   #+END_SRC
** avy
   Use avy to move between visible text.
   #+begin_src emacs-lisp :tangle yes

  (use-package avy
    :bind* (("C-'" . avy-goto-char)
            ("C-," . avy-goto-char-2))
    :config
    (setq avy-keys '(?h ?t ?n ?s)))
   #+end_src
** dumb-jump
   Use it to jump to function definitions. Requires no external depedencies.
   #+begin_src emacs-lisp :tangle no
(use-package dumb-jump
  :diminish dumb-jump-mode
  :bind (("C-M-g" . dumb-jump-go)
         ("C-M-p" . dumb-jump-back)
         ("C-M-q" . dumb-jump-quick-look)))
   #+end_src
** Window switching
   #+begin_src emacs-lisp :tangle yes
  (use-package windmove
    ;; :defer 4
    :ensure t
    :config
    ;; use command key on Mac
    (windmove-default-keybindings 'super)
    ;; wrap around at edges
    (setq windmove-wrap-around t))
   #+end_src
** ace-window (disabled)
   Ace-window makes it easier to move between windows.
   #+begin_src emacs-lisp :tangle no
  (use-package ace-window
    :bind ("M-'" . ace-window)
    :config
    (setq aw-keys '(?h ?t ?n ?s)))
   #+end_src
** dired
*** isearch in dired
    #+BEGIN_SRC emacs-lisp :tangle yes
  (setq dired-isearch-filenames 'dwim)
    #+END_SRC
*** trash files instead of deleting them
    #+BEGIN_SRC emacs-lisp :tangle yes
  (setq delete-by-moving-to-trash t)
    #+END_SRC
*** find-dired
    #+BEGIN_SRC emacs-lisp :tangle yes
  (require 'find-dired)
  (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    #+END_SRC
*** Hide details
    Hide details and only show file and folder names.
    #+begin_src emacs-lisp :tangle no
  (defun jethro/dired-mode-setup-hook ()
    "hook for dired-mode"
    (dired-hide-details-mode 1))

  (add-hook 'dired-mode-hook 'jethro/dired-mode-setup-hook)
    #+end_src
*** Sort directories first
    #+begin_src emacs-lisp :tangle yes
(setq dired-listing-switches "-aBhl  --group-directories-first")
    #+end_src
*** Recursive Copying and Deleting
    #+begin_src emacs-lisp :tangle yes
  (setq dired-recursive-copies (quote always))
  (setq dired-recursive-deletes (quote top))
    #+end_src
*** dired-jump from file
    #+begin_src emacs-lisp :tangle yes
  (require 'dired-x)
    #+end_src
*** allow editing of permissions
    #+BEGIN_SRC emacs-lisp :tangle yes
  (setq wdired-allow-to-change-permissions t)
    #+END_SRC
*** dired-k
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-k
    :config
    (define-key dired-mode-map (kbd "K") 'dired-k)
    (setq dired-k-style 'git))
    #+END_SRC
*** dired-narrow
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("N" . dired-narrow-fuzzy)))
    #+END_SRC
*** dired-ranger
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-ranger
    :bind (:map dired-mode-map
                ("C" . dired-ranger-copy)
                ("P" . dired-ranger-paste)
                ("M" . dired-ranger-move)))
    #+END_SRC
* Editing Text
** visual-regexp
   #+begin_src emacs-lisp :tangle yes
  (use-package visual-regexp
    :bind* (("C-M-%" . vr/query-replace)
            ("C-c m" . vr/mc-mark)))
   #+end_src
** electric-pair mode
   #+begin_src emacs-lisp :tangle yes
  (add-hook 'after-init-hook (lambda () (electric-pair-mode 1)))
   #+end_src
** electric-align
   Use multiple spaces to align code and text.
   #+begin_src emacs-lisp :tangle yes
(use-package electric-align
  :ensure f
  :load-path "elisp/"
  :diminish electric-align-mode
  :config (add-hook 'prog-mode-hook 'electric-align-mode))
   #+end_src
** aggressive-indent
   Keep your text indented at all times. Remember to turn this off for indentation-dependent languages like Python and Haml.
   #+begin_src emacs-lisp :tangle yes
(use-package aggressive-indent
  :diminish aggressive-indent-mode
  :config (add-hook 'prog-mode-hook 'aggressive-indent-mode))
   #+end_src
** multiple-cursors
   A port of Sublime Text's multiple-cursors functionality.
   #+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("C-M-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
   #+end_src
** expand-region
   Use this often, and in combination with multiple-cursors.
   #+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :bind (("C-=" . er/expand-region)))
   #+end_src
** iedit
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package iedit)
   #+END_SRC
** paredit
   For editing Lisp code.
   #+begin_src emacs-lisp :tangle no
(use-package paredit
  :diminish paredit-mode
  :config
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'clojure-mode-hook 'paredit-mode))
   #+end_src
** smartparens
   #+begin_src emacs-lisp :tangle yes
  (use-package smartparens 
    :init
    (add-hook 'emacs-lisp-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'clojure-mode-hook 'turn-on-smartparens-strict-mode)
    :config
    (require 'smartparens-config)
    (setq sp-base-key-bindings 'paredit)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-hybrid-kill-entire-symbol nil)
    (sp-use-paredit-bindings)
    (defmacro def-pairs (pairs)
      `(progn
         ,@(loop for (key . val) in pairs
                 collect
                 `(defun ,(read (concat
                                 "wrap-with-"
                                 (prin1-to-string key)
                                 "s"))
                      (&optional arg)
                    (interactive "p")
                    (sp-wrap-with-pair ,val)))))

    (def-pairs ((paren        . "(")
                (bracket      . "[")
                (brace        . "{")
                (single-quote . "'")
                (double-quote . "\"")
                (back-quote   . "`"))))
   #+end_src
** zap-up-to-char
   #+begin_src emacs-lisp :tangle yes
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR.

    \(fn arg char)"
    'interactive)

  (bind-key* "M-z" 'zap-up-to-char)
   #+end_src
** move-text
   #+begin_src emacs-lisp :tangle yes
  (use-package move-text
    :bind (("M-<up>" . move-text-up)
           ("M-<down>" . move-text-down)))
   #+end_src
** Linting with Flycheck
   #+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :config
    (global-set-key (kbd "C-c f")
                    (defhydra hydra-flycheck
                      (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
                            :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
                            :hint nil)
                      "Errors"
                      ("f"  flycheck-error-list-set-filter                            "Filter")
                      ("n"  flycheck-next-error                                       "Next")
                      ("p"  flycheck-previous-error                                   "Previous")
                      ("<" flycheck-first-error                                      "First")
                      (">"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
                      ("q"  nil)))
    (use-package flycheck-pos-tip
      :config (flycheck-pos-tip-mode))
    (add-hook 'prog-mode-hook 'global-flycheck-mode))
   #+end_src
** Templating with Yasnippet
   #+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish yas-global-mode yas-minor-mode
    :init (add-hook 'after-init-hook 'yas-global-mode)
    :config (setq yas-snippet-dirs '("~/.emacs.d/snippets/")))
   #+end_src
** Autocompletions with Company
   #+begin_src emacs-lisp :tangle yes
(use-package company
  :diminish company-mode
  :init (progn
          (add-hook 'after-init-hook 'global-company-mode)
          (setq company-dabbrev-ignore-case nil
                company-dabbrev-code-ignore-case nil
                company-dabbrev-downcase nil
                company-idle-delay 0
                company-begin-commands '(self-insert-command)
                company-transformers '(company-sort-by-occurrence))
          (use-package company-quickhelp
            :config (company-quickhelp-mode 1))))
   #+end_src
** Spellcheck with Flyspell
   #+begin_src emacs-lisp :tangle yes
  (use-package flyspell 
    :ensure f 
    :diminish flyspell-mode
    :init
    (setenv "DICTIONARY" "en_GB")
    :config   
    (add-hook 'markdown-mode-hook 'flyspell-mode))
   #+end_src
* Language Support
** Common Lisp
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package slime
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))
   #+END_SRC
** Emacs Lisp
   #+begin_src emacs-lisp :tangle yes
  (bind-key "C-c C-k" 'eval-buffer emacs-lisp-mode-map)
   #+end_src
** Nix
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nix-mode
    :config
    (add-hook 'nix-mode-hook (lambda ()
                               (aggressive-indent-mode -1))))
   #+END_SRC
*** completion
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-nixos-options
    :config
    (add-to-list 'company-backends 'company-nixos-options))
    #+END_SRC
** Go
   #+begin_src emacs-lisp :tangle yes
(use-package go-mode
  :mode ("\\.go\\'" . go-mode)
  :config (progn
            (add-hook 'go-mode-hook 'compilation-auto-quit-window)
            (add-hook 'go-mode-hook (lambda ()
                                      (set (make-local-variable 'company-backends) '(company-go))
                                      (company-mode)))
            (add-hook 'go-mode-hook (lambda ()
                                      (add-hook 'before-save-hook 'gofmt-before-save)
                                      (local-set-key (kbd "M-.") 'godef-jump)))
            (add-hook 'go-mode-hook
                      (lambda ()
                        (unless (file-exists-p "Makefile")
                          (set (make-local-variable 'compile-command)
                               (let ((file (file-name-nondirectory buffer-file-name)))
                                 (format "go build %s"
                                         file))))))
            (use-package go-dlv
              :config (require 'go-dlv))
            (use-package golint
              :config
              (add-to-list 'load-path (concat (getenv "GOPATH")  "/src/github.com/golang/lint/misc/emacs"))
              (require 'golint))
            (use-package gorepl-mode
              :config (add-hook 'go-mode-hook #'gorepl-mode))
            (use-package company-go
              :config (add-hook 'go-mode-hook (lambda ()
                                                (set (make-local-variable 'company-backends) '(company-go))
                                                (company-mode))))))
   #+end_src
** C
   #+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'c-mode-hook
            (lambda ()
              (unless (file-exists-p "Makefile")
                (set (make-local-variable 'compile-command)
                     (let ((file (file-name-nondirectory buffer-file-name)))
                       (format "cc -Wall %s -o %s --std=c99"
                               file
                               (file-name-sans-extension file)))))))
   #+END_SRC
** C++
*** C++ compile function
    #+begin_src emacs-lisp :tangle yes
(add-hook 'c++-mode-hook
          (lambda ()
            (unless (file-exists-p "Makefile")
              (set (make-local-variable 'compile-command)
                   (let ((file (file-name-nondirectory buffer-file-name)))
                     (format "g++ -Wall -s -pedantic-errors %s -o %s --std=c++14"
                             file
                             (file-name-sans-extension file)))))))
    #+end_src
** Java
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eclim
    :bind (("<f9>" . eclim-run-class))
    :config 
    (global-eclim-mode)
    (setq help-at-pt-display-when-idle t)
    (setq help-at-pt-timer-delay 0.1)
    (help-at-pt-set-timer))
   #+END_SRC
*** company-emacs-eclim
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-emacs-eclim
    :config
    (company-emacs-eclim-setup))
    #+END_SRC
*** gradle
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gradle-mode
    :diminish gradle-mode
    :config
    (add-hook 'java-mode-hook (lambda ()
                                (gradle-mode 1))))

    #+END_SRC
** Fish
   #+begin_src emacs-lisp :tangle yes
  (use-package fish-mode
    :mode ("\\.fish\\'" . fish-mode)
    :init (add-hook 'fish-mode-hook
                    (lambda () (aggressive-indent-mode -1))))
   #+end_src
** Rust
   #+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
   #+end_src
** Python
   #+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :mode ("\\.py\\'" . elpy-mode)
    :init
    (add-hook 'python-mode-hook (lambda () (aggressive-indent-mode -1)))
    :config
    (when (require 'flycheck nil t)
      (remove-hook 'elpy-modules 'elpy-module-flymake)
      (remove-hook 'elpy-modules 'elpy-module-yasnippet)
      (remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
      (add-hook 'elpy-mode-hook 'flycheck-mode))
    (elpy-enable)
    (setq elpy-rpc-backend "jedi"))
   #+end_src
** HTML
*** Web-mode
    #+begin_src emacs-lisp :tangle yes
   (use-package web-mode
     :mode (("\\.html\\'" . web-mode)
            ("\\.html\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.jinja\\'" . web-mode)
            ("\\.njk\\'" . web-mode)
            ("\\.php\\'" . web-mode))
     :config
     (setq web-mode-enable-css-colorization t)
     (setq web-mode-code-indent-offset 2)
     (setq web-mode-markup-indent-offset 2))
    #+end_src
*** Emmet-mode
    #+begin_src emacs-lisp :tangle yes
(use-package emmet-mode
  :diminish emmet-mode
  :config
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'vue-mode-hook 'emmet-mode))
    #+end_src
** CSS
*** Rainbow-mode
    #+begin_src emacs-lisp :tangle yes
   (use-package rainbow-mode
     :diminish rainbow-mode
     :config
     (add-hook 'css-mode-hook 'rainbow-mode)
     (add-hook 'scss-mode-hook 'rainbow-mode))
    #+end_src
*** SCSS-mode
    #+begin_src emacs-lisp :tangle yes
 (use-package scss-mode
   :mode "\\.scss\\'" 
   :config (progn
             (setq scss-compile-at-save nil)))
    #+end_src
** JS
*** Flycheck
    #+begin_src emacs-lisp :tangle yes
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (flycheck-add-mode 'javascript-eslint 'web-mode)
    #+end_src
*** Skewer
    #+begin_src emacs-lisp :tangle yes
  (use-package skewer-mode  
    :bind (:map skewer-mode-map
                ("C-c C-k" . skewer-load-buffer))
    :config
    (add-hook 'js2-mode-hook 'skewer-mode))
    #+end_src
*** js-comint
    #+begin_src emacs-lisp :tangle no
  (use-package js-comint
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
                (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
                (local-set-key (kbd "C-c b") 'js-send-buffer)
                (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
                (local-set-key (kbd "C-c l") 'js-load-file-and-go))))
    #+end_src
*** JS2-mode

    Here I also added =tern-mode=. This requires the tern executable:
    #+begin_src bash :tangle no
npm install -g tern
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (use-package js2-mode
        :mode ("\\.js\\'" . js2-mode)
        :config
        (use-package tern
          :diminish tern-mode
          :config
          (setq js-switch-indent-offset 2)
          (add-hook 'js2-mode-hook 'tern-mode) 
          (use-package company-tern
            :config
            (add-to-list 'company-backends 'company-tern))))
    #+end_src
*** js-doc
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package js-doc
    :config
    (setq js-doc-mail-address "jethrokuan95@gmail.com"
          js-doc-author (format "Jethro Kuan <%s>" js-doc-mail-address)
          js-doc-url "http://www.jethrokuan.com/"
          js-doc-license "MIT")
    (add-hook 'js2-mode-hook
              #'(lambda ()
                  (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                  (define-key js2-mode-map "@" 'js-doc-insert-tag))))
#+END_SRC
*** JS2-refactor
    #+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-j"))
    #+end_src
*** Vue-mode
    Additional support for Vue.js projects.

    #+begin_src emacs-lisp :tangle yes
 (use-package vue-mode
   :mode "\\.vue\\'")
    #+end_src
** JSON
   #+begin_src emacs-lisp :tangle yes
 (use-package json-mode
   :mode "\\.json\\'"
   :config (add-hook 'json-mode-hook (lambda ()
                                       (make-local-variable 'js-indent-level)
                                       (setq js-indent-level 2))))
   #+end_src
** Markdown
   #+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :config (progn
            (setq markdown-command "multimarkdown")
            (add-hook 'markdown-mode-hook #'trunc-lines-hook)))
   #+end_src
** Clojure
*** Clojure-mode
    #+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode
    :mode (("\\.clj\\'" . clojure-mode)
           ("\\.boot\\'" . clojure-mode)
           ("\\.edn\\'" . clojure-mode)
           ("\\.cljs\\'" . clojurescript-mode)
           ("\\.cljs\\.hl\\'" . clojurescript-mode))
    :init
    (add-hook 'clojure-mode-hook #'eldoc-mode)
    (add-hook 'clojure-mode-hook #'subword-mode)
    (add-hook 'clojure-mode-hook #'cider-mode)
    (add-hook 'clojure-mode-hook #'clj-refactor-mode))
    #+end_src
*** Cider
    #+begin_src emacs-lisp :tangle yes
  (use-package cider
    :init
    (add-hook 'cider-mode-hook #'clj-refactor-mode)
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode)
    :diminish subword-mode
    :config
    (setq nrepl-log-messages t                  
          cider-repl-display-in-current-window t
          cider-repl-use-clojure-font-lock t    
          cider-prompt-save-file-on-load 'always-save
          cider-font-lock-dynamically '(macro core function var)
          nrepl-hide-special-buffers t
          cider-show-error-buffer nil
          cider-overlays-use-font-lock t
          cider-repl-result-prefix ";; => ")
    (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
    (cider-repl-toggle-pretty-printing))
    #+end_src
*** clj-refactor
    #+begin_src emacs-lisp :tangle yes
(use-package clj-refactor
  :defines cljr-add-keybindings-with-prefix
  :diminish clj-refactor-mode
  :config (cljr-add-keybindings-with-prefix "C-c C-j"))
    #+end_src
*** Squiggly-clojure
    #+begin_src emacs-lisp :tangle yes
  (use-package flycheck-clojure
    :config
    (flycheck-clojure-setup))
    #+end_src
** Latex
*** AucTeX
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auctex
    :defer t
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-syntactic-comment t
          ;; Synctex support
          TeX-source-correlate-start-server nil
          ;; Don't insert line-break at inline math
          LaTeX-fill-break-at-separators nil)
    (setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) %o")
                                  ("qpdfview" "qpdfview %o#%(outpage)")))
    (setq TeX-view-program-selection '((output-pdf "qpdfview")
                                       (output-pdf "Evince")))
    (when latex-enable-auto-fill
      (add-hook 'LaTeX-mode-hook 'latex/auto-fill-mode))
    (when latex-enable-folding
      (add-hook 'LaTeX-mode-hook 'TeX-fold-mode))
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode))
    #+END_SRC
*** Autocomplete support
    #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-auctex
    :defer t)
    #+END_SRC
* Visual Enhancements
** linum-mode (Disabled)
   #+begin_src emacs-lisp :tangle no
(add-hook 'prog-mode-hook 
  (lambda ()
    (linum-mode 1)))
   #+end_src
** hl-line-mode
   #+begin_src emacs-lisp :tangle yes
(global-hl-line-mode 1)
   #+end_src
** whitespace-mode
   Show fill-column.
   #+begin_src emacs-lisp :tangle yes
(require 'whitespace)
(setq whitespace-line-column 80) ;; limit line length
(setq whitespace-style '(face lines-tail))

(add-hook 'prog-mode-hook 'whitespace-mode)
   #+end_src
** Page-break-lines
   #+begin_src emacs-lisp :tangle yes
(use-package page-break-lines)
   #+end_src
** Smart-mode-line
   #+begin_src emacs-lisp :tangle no
  (use-package smart-mode-line
    :config
    (add-hook 'after-init-hook 'sml/setup)
    (setq sml/name-width 30)
    (setq sml/shorten-directory t)
    (setq sml/shorten-modes t)
    (setq sml/mode-width 'full)
    (setq sml/replacer-regexp-list
          '(("^~/.org/" ":O:")
            ("^~/\\.emacs\\.d/" ":ED")))
    (setq rm-blacklist
          (format "^ \\(%s\\)$"
                  (mapconcat #'identity
                             '("FlyC.*"
                               "Projectile.*"
                               "GitGutter"
                               "ivy"
                               "company"
                               ""
                               "doom"
                               ","
                               "ElDoc")
                             "\\|"))))
   #+end_src
*** Showing time
    #+begin_src emacs-lisp :tangle yes
(setq display-time-24hr-format t)
(display-time-mode 1)
    #+end_src
** nyan-mode
   #+begin_src emacs-lisp :tangle no
  (use-package nyan-mode
    :config
    (nyan-mode 1))
   #+end_src
** Zooming
   #+begin_src emacs-lisp :tangle yes
(defhydra hydra-zoom (global-map "<f2>")
  "zoom"
  ("i" text-scale-increase "in")
  ("o" text-scale-decrease "out"))
   #+end_src
** beacon
   Beacon makes sure you don't lose track of your cursor when jumping around a buffer.
   #+begin_src emacs-lisp :tangle yes
  (use-package beacon
    :diminish beacon-mode
    :config
    (beacon-mode 1)
    (setq beacon-push-mark 10))
   #+end_src
** show-paren
   Always show matching parenthesis.
   #+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)
(setq show-paren-delay 0)
   #+end_src
** golden-ratio
   Give the working window more screen estate.
   #+begin_src emacs-lisp :tangle yes
(use-package golden-ratio
  :diminish golden-ratio-mode
  :config (progn
            (add-to-list 'golden-ratio-extra-commands 'ace-window)
            (golden-ratio-mode 1)))
   #+end_src
** volatile-highlights
   Highlights recently copied/pasted text.
   #+begin_src emacs-lisp :tangle yes
(use-package volatile-highlights
  :diminish volatile-highlights-mode
  :config (volatile-highlights-mode t))
   #+end_src
** git-gutter-fringe+
   Displays added/modified/deleted on the left.
   #+begin_src emacs-lisp :tangle yes
  (use-package git-gutter-fringe+
    :config
    (global-git-gutter+-mode)
    (set-face-foreground 'git-gutter+-modified "gold1")
    (set-face-foreground 'git-gutter+-added    "SeaGreen")
    (set-face-foreground 'git-gutter+-deleted  "IndianRed")
    (setq git-gutter-fr+-side 'left-fringe))
   #+end_src
* Org-mode
** Getting Started
   :PROPERTIES:
   :CUSTOM_ID: GettingStarted
   :END:
*** Org-Mode Setup
    :PROPERTIES:
    :CUSTOM_ID: Setup
    :END:
 #+begin_src emacs-lisp :tangle yes
   (use-package org-plus-contrib
     :bind (("C-c l" . org-store-link)
            ("C-c a" . org-agenda)
            ("C-c b" . org-iswitchb)
            ("C-c c" . org-capture))
     :config
     (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode)))
 #+end_src
*** Enabling auto-fill-mode
This enables `auto-fill-mode` for org-mode files
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'org-mode-hook (lambda ()
                             (auto-fill-mode 1)))
#+END_SRC
*** Agenda Setup
 #+begin_src emacs-lisp :tangle yes
   (setq org-agenda-files (file-expand-wildcards "~/.org/gtd/[a-zA-z]*.org"))
 #+end_src

    :CUSTOM_ID: OrgFileStructure
    :END:
*** Key bindings
    :PROPERTIES:
    :CUSTOM_ID: KeyBindings
    :END:
 Here is the keybinding setup in lisp:
 #+header: :tangle yes
 #+begin_src emacs-lisp
   (global-set-key (kbd "<f11>") 'org-clock-goto)
 #+end_src
** Column view
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-columns-default-format "%Effort{:} %5CLOCKSUM(CLK) %5CLOCKSUM_T(CLK_T) %1PRIORITY(P) %TODO %ITEM")
#+END_SRC
** Tasks and States
   :PROPERTIES:
   :CUSTOM_ID: TasksAndStates
   :END:

 I use one set of TODO keywords for all of my org files.  Org-mode lets
 you define TODO keywords per file but I find it's easier to have a
 standard set of TODO keywords globally so I can use the same setup in
 any org file I'm working with.

 The only exception to this is this document :) since I don't want
 =org-mode= hiding the =TODO= keyword when it appears in headlines.
 I've set up a dummy =#+SEQ_TODO: FIXME FIXED= entry at the top of this
 file just to leave my =TODO= keyword untouched in this document.
*** TODO keywords
    :PROPERTIES:
    :CUSTOM_ID: TodoKeywords
    :END:

 I use a light colour theme in emacs.  I find this easier to read on bright sunny days.

 Here are my =TODO= state keywords and colour settings:

 #+header: :tangle yes
 #+begin_src emacs-lisp
   (setq org-todo-keywords
         (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                 (sequence "WAITING(w@/!)" "HOLD(h@/!)"))))
 #+end_src
**** Task States
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordTaskStates
     :END:

 Tasks go through the sequence =TODO= -> =DONE=.

 The following diagram shows the possible state transitions for a task.

 #+begin_src plantuml :file normal_task_states.png :cache yes
 title Task States
 [*] -> TODO
 TODO -> NEXT
 TODO -> DONE
 NEXT -> DONE
 DONE -> [*]
 TODO --> WAITING
 WAITING --> TODO
 NEXT --> WAITING
 WAITING --> NEXT
 HOLD --> CANCELLED
 WAITING --> CANCELLED
 CANCELLED --> [*]
 TODO --> HOLD
 HOLD --> TODO
 TODO --> CANCELLED
 TODO: t
 NEXT: n
 DONE: d
 WAITING:w
 note right of WAITING: Note records\nwhat it is waiting for
 HOLD:h
 note right of CANCELLED: Note records\nwhy it was cancelled
 CANCELLED:c
 WAITING --> DONE
 #+end_src

 #+results[61c867b8eb4f49bc47e44ec2b534ac3219d82594]:
 [[file:normal_task_states.png]]

**** Project Task States
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordProjectTaskStates
     :END:

 I use a lazy project definition.  I don't like to bother with manually
 stating 'this is a project' and 'that is not a project'.  For me a project
 definition is really simple.  If a task has subtasks with a todo keyword
 then it's a project.  That's it.

 Projects can be defined at any level - just create a task with a todo
 state keyword that has at least one subtask also with a todo state
 keyword and you have a project.  Projects use the same todo keywords
 as regular tasks.  One subtask of a project needs to be marked =NEXT=
 so the project is not on the stuck projects list.
**** Phone Calls
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordPhoneCalls
     :END:

 Telephone calls are special.  They are created in a done state by a capture task.
 The time of the call is recorded for as long as the capture task is active.  If I need 
 to look up other details and want to close the capture task early I can just 
 =C-c C-c= to close the capture task (stopping the clock) and then =f9 SPC= to resume
 the clock in the phone call while I do other things.
 #+begin_src plantuml :file phone_states.png :cache yes
 title Phone Call Task State
 [*] -> PHONE
 PHONE -> [*]
 #+end_src

 #+results[9e27f3a56c4fca8f05455e6dfa1282030ae52830]:
 [[file:phone_states.png]]

**** Meetings
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordMeetings
     :END:

 Meetings are special.  They are created in a done state by a capture
 task.  I use the MEETING capture template when someone interrupts what
 I'm doing with a question or discussion.  This is handled similarly to
 phone calls where I clock the amount of time spent with whomever it is
 and record some notes of what was discussed (either during or after
 the meeting) depending on content, length, and complexity of the
 discussion.

 The time of the meeting is recorded for as long as the capture task is
 active.  If I need to look up other details and want to close the
 capture task early I can just =C-c C-c= to close the capture task
 (stopping the clock) and then =f9 SPC= to resume the clock in the
 meeting task while I do other things.
 #+begin_src plantuml :file meeting_states.png :cache yes
 title Meeting Task State
 [*] -> MEETING
 MEETING -> [*]
 #+end_src

 #+results[942fb408787905ffcdde421ee02edabdbb921b06]:
 [[file:meeting_states.png]]

*** Fast Todo Selection
    :PROPERTIES:
    :CUSTOM_ID: FastTodoSelection
    :END:

 Fast todo selection allows changing from any task todo state to any
 other state directly by selecting the appropriate key from the fast
 todo selection key menu.  This is a great feature!

 #+header: :tangle yes
 #+begin_src emacs-lisp 
 (setq org-use-fast-todo-selection t)
 #+end_src

 Changing a task state is done with =C-c C-t KEY=

 where =KEY= is the appropriate fast todo state selection key as defined in =org-todo-keywords=.

 The setting
 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-treat-S-cursor-todo-selection-as-state-change nil)
 #+end_src
 allows changing todo states with S-left and S-right skipping all of
 the normal processing when entering or leaving a todo state.  This
 cycles through the todo states but skips setting timestamps and
 entering notes which is very convenient when all you want to do is fix
 up the status of an entry.
*** TODO state triggers
    :PROPERTIES:
    :CUSTOM_ID: ToDoStateTriggers
    :END:

 I have a few triggers that automatically assign tags to tasks based on
 state changes.  If a task moves to =CANCELLED= state then it gets a
 =CANCELLED= tag.  Moving a =CANCELLED= task back to =TODO= removes the
 =CANCELLED= tag.  These are used for filtering tasks in agenda views
 which I'll talk about later.

 The triggers break down to the following rules:

 - Moving a task to =CANCELLED= adds a =CANCELLED= tag
 - Moving a task to =WAITING= adds a =WAITING= tag
 - Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
 - Moving a task to a done state removes =WAITING= and =HOLD= tags
 - Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
 - Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
 - Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags

 The tags are used to filter tasks in the agenda views conveniently.

 #+header: :tangle yes
 #+begin_src emacs-lisp 
 (setq org-todo-state-tags-triggers
       (quote (("CANCELLED" ("CANCELLED" . t))
               ("WAITING" ("WAITING" . t))
               ("HOLD" ("WAITING") ("HOLD" . t))
               (done ("WAITING") ("HOLD"))
               ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
               ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
               ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
 #+end_src
*** Clocking
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun jethro/clock-in-to-next (kw)
    "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"))
             (bh/is-task-p))
        "NEXT")
       ((and (member (org-get-todo-state) (list "NEXT"))
             (bh/is-project-p))
        "TODO"))))

  (setq org-clock-in-switch-to-state 'jethro/clock-in-to-next)
#+END_SRC
** Adding New Tasks Quickly with Org Capture
   :PROPERTIES:
   :CUSTOM_ID: Capture
   :END:
*** Capture Templates
    :PROPERTIES:
    :CUSTOM_ID: CaptureTemplates
    :END:
 #+begin_src emacs-lisp :tangle yes
   (setq org-directory "~/.org/gtd/")
   (setq org-default-notes-file "~/.org/gtd/inbox.org")

   (defvar jethro/org-basic-inbox-template "* TODO [#B] %?
   :PROPERTIES:
   :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
   :END:
   Captured %<%Y-%m-%d %H:%M>
   %a
   %i
   ")

   (require 'org-protocol)

   ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
   (setq org-capture-templates
         `(("t" "todo" entry (file "~/.org/gtd/inbox.org")
            ,jethro/org-basic-inbox-template)
           ("r" "respond" entry (file "~/.org/gtd/inbox.org")
            "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
           ("w" "Web site" entry (file "~/.org/gtd/websites.org")
            "* %c\n %(progn (setq jethro/delete-frame-after-capture t))" :immediate-finish t)))
 #+end_src
** org-capture shortcut
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar jethro/delete-frame-after-capture nil
    "Whether to delete the last frame after the current capture")

  (defun jethro/delete-frame-if-neccessary (&rest r)
    (if (or (equal "capture" (frame-parameter nil 'name))
            jethro/delete-frame-after-capture)
        (progn
          (setq jethro/delete-frame-after-capture nil)
          (delete-frame))
      (setq jethro/delete-frame-after-capture nil)))

  (defadvice org-switch-to-buffer-other-window
      (after supress-window-splitting activate)
    "Delete the extra window if we're in a capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-other-windows)))

  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (select-frame
     (make-frame '((window-system . x)
                   (name . "capture")
                   (width . 120)
                   (height . 15)))) 
    (setq word-wrap 1)
    (setq truncate-lines nil)
    (setq jethro/delete-frame-after-capture t)
    (org-capture nil "t"))

  (advice-add 'org-capture-finalize :after 'jethro/delete-frame-if-neccessary)
  (advice-add 'org-capture-kill :after 'jethro/delete-frame-if-neccessary)
  (advice-add 'org-capture-refile :after 'jethro/delete-frame-if-neccessary)
#+END_SRC
** Refiling Tasks
   :PROPERTIES:
   :CUSTOM_ID: Refiling
   :END:
*** Refile Setup
    :PROPERTIES:
    :CUSTOM_ID: RefileSetup
    :END:
 Here is my refile configuration:
 #+header: :tangle yes
 #+begin_src emacs-lisp
   ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
   (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                    (org-agenda-files :maxlevel . 9))))

   ; Use full outline paths for refile targets - we file directly with IDO
   (setq org-refile-use-outline-path t)

   ; Targets complete directly with IDO
   (setq org-outline-path-complete-in-steps nil)

   ; Allow refile to create parent tasks with confirmation
   (setq org-refile-allow-creating-parent-nodes 'confirm)

   (setq org-completion-use-ido t)

   ;;;; Refile settings
   (defun jethro/verify-refile-target ()
     "Exclude todo keywords with a done state from refile targets"
     (not (member (nth 2 (org-heading-components)) org-done-keywords)))

   (setq org-refile-target-verify-function 'jethro/verify-refile-target)
 #+end_src

** Custom agenda views
   :PROPERTIES:
   :CUSTOM_ID: CustomAgendaViews
   :END:
*** Setup
    :PROPERTIES:
    :CUSTOM_ID: CustomAgendaViewSetup
    :END:

 #+header: :tangle yes
 #+begin_src emacs-lisp
   ;; Do not dim blocked tasks
   (setq org-agenda-dim-blocked-tasks nil)

   ;; Compact the block agenda view
   (setq org-agenda-compact-blocks t)

   ;; Custom agenda command definitions
   (setq org-agenda-custom-commands
         '((" " "Agenda"
            ((agenda "" nil)
             (tags "REFILE"
                   ((org-agenda-overriding-header "Tasks to Refile")
                    (org-tags-match-list-sublevels nil)))
             (todo "NEXT"
                   ((org-agenda-overriding-header "School Next Tasks")
                    (org-agenda-todo-ignore-scheduled t)
                    (org-agenda-todo-ignore-deadlines t)
                    (org-agenda-files '("~/.org/gtd/school.org"))))
             (todo "TODO"
                   ((org-agenda-overriding-header "School Todos")
                    (org-agenda-todo-ignore-scheduled t)
                    (org-agenda-todo-ignore-deadlines t) 
                    (org-agenda-files '("~/.org/gtd/school.org"))))
             (tags-todo "-CANCELLED/!"
                        ((org-agenda-overriding-header "Stuck Projects")
                         (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                         (org-agenda-sorting-strategy '(category-keep)))) 
             (tags-todo "-HOLD-CANCELLED/!"
                        ((org-agenda-overriding-header "Projects")
                         (org-agenda-skip-function 'bh/skip-non-projects)
                         (org-tags-match-list-sublevels 'indented)
                         (org-agenda-sorting-strategy '(category-keep))))
             (tags-todo "-CANCELLED/!NEXT"
                        ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                         (org-tags-match-list-sublevels t)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(todo-state-down effort-up category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Project Subtasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)"))) 
                         (org-agenda-skip-function 'bh/skip-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-CANCELLED+WAITING|HOLD/!"
                        ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-tasks)
                         (org-tags-match-list-sublevels nil)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks))) 
             (tags "-REFILE/"
                   ((org-agenda-overriding-header "Tasks to Archive")
                    (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                    (org-tags-match-list-sublevels nil))))
            nil)))
 #+end_src

 My day goes generally like this:

 - Punch in (this starts the clock on the default task)
 - Look at the agenda and make a mental note of anything important to deal with today
 - Read email and news
   - create notes, and tasks for things that need responses with org-capture
 - Check refile tasks and respond to emails
 - Look at my agenda and work on important tasks for today
   - Clock it in
   - Work on it until it is =DONE= or it gets interrupted
 - Work on tasks
 - Make journal entries (=C-c c j=) for interruptions
 - Punch out for lunch and punch back in after lunch
 - work on more tasks
 - Refile tasks to empty the list
   - Tag tasks to be refiled with =m= collecting all tasks for the same target
   - Bulk refile the tasks to the target location with =B r=
   - Repeat (or refile individually with =C-c C-w=) until all refile tasks are gone
 - Mark habits done today as DONE
 - Punch out at the end of the work day
*** What do I work on next?
    :PROPERTIES:
    :CUSTOM_ID: WhatDoIWorkOnNext
    :END:

 Start with deadlines and tasks scheduled today or earlier from the
 daily agenda view.  Then move on to tasks in the =Next Tasks= list in
 the block agenda view.  I tend to schedule current projects to 'today'
 when I start work on them and they sit on my daily agenda reminding me
 that they need to be completed.  I normally only schedule one or two
 projects to the daily agenda and unschedule things that are no longer
 important and don't deserve my attention today.

 When I look for a new task to work on I generally hit =F12 SPC= to get
 the block agenda and follow this order:

 - Pick something off today's agenda
   - deadline for today (do this first - it's not late yet)
   - deadline in the past (it's already late)
   - a scheduled task for today (it's supposed to be done today)
   - a scheduled task that is still on the agenda
   - deadline that is coming up soon
 - pick a NEXT task
 - If you run out of items to work on look for a NEXT task in the current context
   pick a task from the Tasks list of the current project.
**** Why keep it all on the =NEXT= list?
     :PROPERTIES:
     :CUSTOM_ID: CustomAgendaViewsNextList
     :END:

 I've moved to a more GTD way of doing things.  Now I just use a =NEXT=
 list.  Only projects get tasks with =NEXT= keywords since stuck projects
 initiate the need for marking or creating =NEXT= tasks.  A =NEXT= task
 is something that is available to work on /now/, it is the next
 logical step in some project.

 To drop a task off the =NEXT= list simply move it back to the =TODO=
 state.
*** Filtering
    :PROPERTIES:
    :CUSTOM_ID: CustomAgendaViewFiltering
    :END:

 So many tasks, so little time.  I have hundreds of tasks at any given
 time (373 right now).  There is so much stuff to look at it can be
 daunting.  This is where agenda filtering saves the day.

 It's 11:53AM and I'm in work mode just before lunch.  I don't want to
 see tasks that are not work related right now.  I also don't want to
 work on a big project just before lunch... so I need to find small
 tasks that I can knock off the list.

 How do we do this?  Get a list of NEXT tasks from the block agenda and
 then narrow it down with filtering.  Tasks are ordered in the NEXT
 agenda view by estimated effort so the short tasks are first -- just
 start at the top and work your way down.  I can limit the displayed
 agenda tasks to those estimates of 10 minutes or less with =/ + 1= and
 I can pick something that fits the minutes I have left before I take
 off for lunch.
**** Automatically removing context based tasks with / RET
     :PROPERTIES:
     :CUSTOM_ID: CustomAgendaViewFilteringContext
     :END:

 =/ RET= in the agenda is really useful.  This awesome feature was
 added to org-mode by John Wiegley.  It removes tasks automatically by
 filtering based on a user-provided function.

 At work I have projects I'm working on which are assigned by my
 manager.  Sometimes priorities changes and projects are delayed to
 sometime in the future.  This means I need to stop working on these
 immediately.  I put the project task on =HOLD= and work on something
 else.  The =/ RET= filter removes =HOLD= tasks and subtasks (because
 of tag inheritance).

 At home I have some tasks tagged with =farm= since these need to be
 performed when I am physically at our family farm.  Since I am there
 infrequently I have added =farm= to the list of auto-excluded tags on
 my system.  I can always explicitly filter to just =farm= tasks with
 =/ TAB farm RET= when I am physically there.

 I have the following setup to allow =/ RET= to filter tasks based on
 the description above.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (defun bh/org-auto-exclude-function (tag)
   "Automatic task exclusion in the agenda with / RET"
   (and (cond
         ((string= tag "hold")
          t)
         ((string= tag "farm")
          t))
        (concat "-" tag)))

 (setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
 #+end_src

 This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not
 supposed to be working on now from the list of returned results.

 This helps to keep my agenda clutter-free.
** Tags
   :PROPERTIES:
   :CUSTOM_ID: Tags
   :END:

 Tasks can have any number of arbitrary tags.  Tags are used for:

 - filtering todo lists and agenda views
 - providing context for tasks
 - tagging notes
 - tagging phone calls
 - tagging meetings
 - tagging tasks to be refiled
 - tagging tasks in a WAITING state because a parent task is WAITING
 - tagging cancelled tasks because a parent task is CANCELLED
 - preventing export of some subtrees when publishing

 I use tags mostly for filtering in the agenda.  This means you can
 find tasks with a specific tag easily across your large number of
 org-mode files.

*** Tags
    :PROPERTIES:
    :CUSTOM_ID: OrgTagAlist
    :END:

 Here are my tag definitions with associated keys for filtering in the
 agenda views.

 The startgroup - endgroup (=@XXX=) tags are mutually exclusive -
 selecting one removes a similar tag already on the task.  These are
 the context tags - you can't be in two places at once so if a task is
 marked with @farm and you add @office then the @farm tag is removed
 automagically.

 The other tags =WAITING= .. =FLAGGED= are not mutually exclusive and
 multiple tags can appear on a single task.  Some of those tags are
 created by todo state change triggers.  The shortcut key is used to
 add or remove the tag using =C-c C-q= or to apply the task for
 filtering on the agenda.

 I have both =FARM= and =@farm= tags.  =FARM= is set by a =FILETAGS=
 entry and just gives me a way to filter anything farm related.  The
 =@farm= tag signifies that the task as to be done /at the farm/.  If I
 have to call someone about something that would have a =FARM= tag but
 I can do that at home on my lunch break.  I don't physically have to
 be at the farm to make the call.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 ; Tags with fast selection keys
 (setq org-tag-alist (quote ((:startgroup)
                             ("@errand" . ?e)
                             ("@office" . ?o)
                             ("@home" . ?H)
                             ("@farm" . ?f)
                             (:endgroup)
                             ("WAITING" . ?w)
                             ("HOLD" . ?h)
                             ("PERSONAL" . ?P)
                             ("WORK" . ?W)
                             ("FARM" . ?F)
                             ("ORG" . ?O)
                             ("NORANG" . ?N)
                             ("crypt" . ?E)
                             ("NOTE" . ?n)
                             ("CANCELLED" . ?c)
                             ("FLAGGED" . ??))))

 ; Allow setting single tags without the menu
 (setq org-fast-tag-selection-single-key (quote expert))

 ; For tag searches ignore tasks with scheduled and deadline dates
 (setq org-agenda-tags-todo-honor-ignore-options t)
 #+end_src
*** Filetags
    :PROPERTIES:
    :CUSTOM_ID: FileTags
    :END:

 Filetags are a convenient way to apply one or more tags to all of the
 headings in a file.

 Filetags look like this:

 #+begin_src org :exports src
 ,#+FILETAGS: NORANG @office
 #+end_src

 I have the following =#+FILETAGS:= entries in my org-mode files:
**** Non-work related org-mode files
     :PROPERTIES:
     :CUSTOM_ID: TaggingNonWorkFiles
     :END:

 | File         | Tags                  |
 |--------------+-----------------------|
 | todo.org     | PERSONAL              |
 | gsoc2009.org | GSOC PERSONAL         |
 | git.org      | GIT WORK              |
 | org.org      | ORG WORK              |
 | mark.org     | MARK PERSONAL         |
 | farm.org     | FARM PERSONAL         |
**** Work related org-mode files
     :PROPERTIES:
     :CUSTOM_ID: TaggingWorkFiles
     :END:

 | File        | Tags            |
 |-------------+-----------------|
 | norang.org  | NORANG @office  |
 | ABC.org     | ABC @office     |
 | XYZ.org     | XYZ @office     |
 | ABC-DEF.org | ABC DEF @office |
 | ABC-KKK.org | ABC KKK @office |
 | YYY.org     | YYY @office     |
**** Refile tasks
     :PROPERTIES:
     :CUSTOM_ID: RefileTasks
     :END:

 | File       | Tags         |
 |------------+--------------|
 | refile.org | REFILE       |
 |------------+--------------|
*** State Trigger Tags
    :PROPERTIES:
    :CUSTOM_ID: StateTriggerTags
    :END:

 The following tags are automatically added or removed by todo state
 triggers described previously in [[#ToDoStateTriggers][ToDo state triggers]]

 - =WAITING=
   - =CANCELLED=
** GTD stuff
   :PROPERTIES:
   :CUSTOM_ID: GTD
   :
 Most of my day is deadline/schedule driven.
 I work off of the agenda first and then pick items from the todo lists as
 outlined in [[#WhatDoIWorkOnNext][What do I work on next?]]
*** Weekly Review Process
    :PROPERTIES:
    :CUSTOM_ID: GTDWeeklyReview
    :END:

 The first day of the week (usually Monday) I do my weekly review. 
 I keep a list like this one to remind me what needs to be done.

 To keep the agenda fast I set
 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-agenda-span 'day)
 #+end_src
 so only today's date is shown by default.  I only need the weekly
 view during my weekly review and this keeps my agenda generation
 fast.

 I have a recurring task which keeps my weekly review checklist
 handy.  This pops up as a reminder on Monday's.  This week I'm
 doing my weekly review on Tuesday since Monday was a holiday.

 #+begin_src org :exports src
 ,* NEXT Weekly Review [0/6]
   SCHEDULED: <2009-05-18 Mon ++1w> 
   :LOGBOOK:...
   :PROPERTIES:...

   What to review:

    - [ ] Check follow-up folder
    - [ ] Review weekly agenda =F12 a w //=
    - [ ] Check clocking data for past week =v c=
    - [ ] Review clock report for past week =R=
      - Check where we spent time (too much or too little) and rectify this week
    - [ ] Look at entire agenda for today  =F12 SPC=
    - [ ] Review projects =F12 SPC //= and =V= repeatedly to view each project

    - start work
      - daily agenda first - knock off items
      - then work on NEXT tasks
 #+end_src
 The first item [ ] Check follow-up folder makes me pull out the paper
 file I dump stuff into all week long - things I need to take care of
 but are in no particular hurry to deal with.  Stuff I get in the mail
 etc. that I don't want to deal with now.  I just toss it in my
 =Follow-Up= folder in the filing cabinet and forget about it until the
 weekly review.

 I go through the folder and weed out anything that needs to be dealt
 with.  After that everything else is in =org-mode=.  I tend to
 schedule tasks onto the agenda for the coming week so that I don't
 spend lots of time trying to find what needs to be worked on next.

 This works for me.  Your mileage may vary ;)
*** Project definition and finding stuck projects
    :PROPERTIES:
    :CUSTOM_ID: Projects
    :END:

 I'm using a new lazy project definition to mark tasks as projects.
 This requires zero effort from me.  Any task with a subtask using a
 todo keyword is a project.  Period.

 Projects are 'stuck' if they have no subtask with a =NEXT= todo
 keyword task defined.

 The org-mode stuck projects agenda view lists projects that have no
 =NEXT= task defined.  Stuck projects show up on my block agenda and I
 tend to assign a =NEXT= task so the list remains empty.  This helps to
 keep projects moving forward.

 I disable the default org-mode stuck projects agenda view with the
 following setting.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-stuck-projects (quote ("" nil nil "")))
 #+end_src

 This prevents org-mode from trying to show incorrect data if I select
 the default stuck project view with =F12 #= from the agenda menu.  My
 customized stuck projects view is part of my block agenda displayed
 with =F12 SPC=.

 Projects can have subprojects - and these subprojects can also be stuck.
 Any project that is stuck shows up on the stuck projects list so I can
 indicate or create a =NEXT= task to move that project forward.

 In the following example =Stuck Project A= is stuck because it has no
 subtask which is =NEXT=.  =Project C= is not stuck because it has
 =NEXT= tasks =SubTask G= and =Task I=.  =Stuck Sub Project D= is stuck
 because =SubTask E= is not =NEXT= and there are no other tasks
 available in this project.

 #+begin_src org :exports src
 ,* Category
 ,** TODO Stuck Project A
 ,*** TODO Task B
 ,** TODO Project C
 ,*** TODO Stuck Sub Project D
 ,**** TODO SubTask E
 ,*** TODO Sub Project F
 ,**** NEXT SubTask G
 ,**** TODO SubTask H
 ,*** NEXT Task I
 ,*** TODO Task J
 #+end_src

 All of the stuck projects and subprojects show up in the stuck
 projects list and that is my indication to assign or create =NEXT=
 tasks until the stuck projects list is empty.  Occasionally some
 subtask is =WAITING= for something and the project is stuck until that
 condition is satisfied.  In this case I leave it on the stuck project
 list and just work on something else.  This stuck project 'bugs' me
 regularly when I see it on the block agenda and this prompts me to
 follow up on the thing that I'm waiting for.

 I have the following helper functions defined for projects which are
 used by agenda views.
 #+header: :tangle yes
 #+begin_src emacs-lisp
   (defun bh/is-project-p ()
     "Any task with a todo keyword subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task has-subtask))))

   (defun bh/is-project-subtree-p ()
     "Any task with a todo keyword that is in a project subtree.
   Callers of this function already widen the buffer view."
     (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                 (point))))
       (save-excursion
         (bh/find-project-task)
         (if (equal (point) task)
             nil
           t))))

   (defun bh/is-task-p ()
     "Any task with a todo keyword and no subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task (not has-subtask)))))

   (defun bh/is-subproject-p ()
     "Any task which is a subtask of another project"
     (let ((is-subproject)
           (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
       (save-excursion
         (while (and (not is-subproject) (org-up-heading-safe))
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq is-subproject t))))
       (and is-a-task is-subproject)))

   (defun bh/list-sublevels-for-projects-indented ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
     This is normally used by skipping functions where this variable is already local to the agenda."
     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels 'indented)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defun bh/list-sublevels-for-projects ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
     This is normally used by skipping functions where this variable is already local to the agenda."
     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels t)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defvar bh/hide-scheduled-and-waiting-next-tasks t)

   (defun bh/toggle-next-task-display ()
     (interactive)
     (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
     (when  (equal major-mode 'org-agenda-mode)
       (org-agenda-redo))
     (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

   (defun bh/skip-stuck-projects ()
     "Skip trees that are not stuck projects"
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (if (bh/is-project-p)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                   (unless (member "WAITING" (org-get-tags-at))
                     (setq has-next t))))
               (if has-next
                   nil
                 next-headline)) ; a stuck project, has subtasks but no next task
           nil))))

   (defun bh/skip-non-stuck-projects ()
     "Skip trees that are not stuck projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (if (bh/is-project-p)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                   (unless (member "WAITING" (org-get-tags-at))
                     (setq has-next t))))
               (if has-next
                   next-headline
                 nil)) ; a stuck project, has subtasks but no next task
           next-headline))))

   (defun bh/skip-non-projects ()
     "Skip trees that are not projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (if (save-excursion (bh/skip-non-stuck-projects))
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((bh/is-project-p)
               nil)
              ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
               nil)
              (t
               subtree-end))))
       (save-excursion (org-end-of-subtree t))))

   (defun bh/skip-non-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, and project related tasks."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-task-p)
           nil)
          (t
           next-headline)))))

   (defun bh/skip-project-trees-and-habits ()
     "Skip trees that are projects"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          (t
           nil)))))

   (defun bh/skip-projects-and-habits-and-single-tasks ()
     "Skip trees that are projects, tasks that are habits, single non-project tasks"
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond 
          ((and bh/hide-scheduled-and-waiting-next-tasks
                (member "WAITING" (org-get-tags-at)))
           next-headline)
          ((bh/is-project-p)
           next-headline)
          ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
           next-headline)
          (t
           nil)))))

   (defun bh/skip-project-tasks-maybe ()
     "Show tasks related to the current restriction.
   When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
   When not restricted, skip project and sub-project tasks, habits, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max))))
              (limit-to-project (marker-buffer org-agenda-restrict-begin)))
         (cond
          ((bh/is-project-p)
           next-headline) 
          ((and (not limit-to-project)
                (bh/is-project-subtree-p))
           subtree-end)
          ((and limit-to-project
                (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-project-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          ((bh/is-project-subtree-p)
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-non-project-tasks ()
     "Show project tasks.
   Skip project and sub-project tasks, habits, and loose non-project tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-project-p) next-headline) 
          ((and (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          ((not (bh/is-project-subtree-p))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-projects-and-habits ()
     "Skip trees that are projects and tasks that are habits"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          (t
           nil)))))

   (defun bh/skip-non-subprojects ()
     "Skip trees that are not projects"
     (let ((next-headline (save-excursion (outline-next-heading))))
       (if (bh/is-subproject-p)
           nil
         next-headline)))

   (defun bh/find-project-task ()
     "Move point to the parent (project) task if any"
     (save-restriction
       (widen)
       (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
         (while (org-up-heading-safe)
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq parent-task (point))))
         (goto-char parent-task)
         parent-task)))
 #+end_src
*** Effort Estimates
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-global-properties (quote (("Effort_ALL" . "0 0:10 0:20 0:30 1:00 1:30 2:00 3:00 4:00 6:00 8:00 10:00 20:00"))))
#+END_SRC
** Archiving
   :PROPERTIES:
   :CUSTOM_ID: Archiving
   :END:
*** Archive Setup
    :PROPERTIES:
    :CUSTOM_ID: ArchiveSetup
    :END:
 #+begin_src emacs-lisp :tangle yes
 (setq org-archive-mark-done nil)
 (setq org-archive-location "%s_archive::* Archived Tasks")
 #+end_src

 #+begin_src emacs-lisp :tangle yes
 (defun bh/skip-non-archivable-tasks ()
   "Skip trees that are not available for archiving"
   (save-restriction
     (widen)
     ;; Consider only tasks with done todo headings as archivable candidates
     (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (subtree-end (save-excursion (org-end-of-subtree t))))
       (if (member (org-get-todo-state) org-todo-keywords-1)
           (if (member (org-get-todo-state) org-done-keywords)
               (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                      (a-month-ago (* 60 60 24 (+ daynr 1)))
                      (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                      (this-month (format-time-string "%Y-%m-" (current-time)))
                      (subtree-is-current (save-excursion
                                            (forward-line 1)
                                            (and (< (point) subtree-end)
                                                 (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                 (if subtree-is-current
                     subtree-end ; Has a date in this month or last month, skip it
                   nil))  ; available to archive
             (or subtree-end (point-max)))
         next-headline))))
 #+end_src
** Reminders
   :PROPERTIES:
   :CUSTOM_ID: Reminders
   :END:

 I use appt for reminders.  It's simple and unobtrusive -- putting
 pending appointments in the status bar and beeping as 12, 9, 6, 3,
 and 0 minutes before the appointment is due.

 Everytime the agenda is displayed (and that's lots for me) the
 appointment list is erased and rebuilt from the current agenda
 details for today.  This means everytime I reschedule something, add
 or remove tasks that are time related the appointment list is
 automatically updated the next time I look at the agenda.
*** Reminder Setup
    :PROPERTIES:
    :CUSTOM_ID: ReminderSetup
    :END:

 #+header: :tangle yes
 #+begin_src emacs-lisp
   (use-package org-alert
     :config
     (org-alert-enable)
     (setq alert-default-style 'libnotify))
 #+end_src
** Htmlize
We need =htmlize= to add syntax highlighting to org-exports for HTML files.

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :config
    (require 'htmlize))
#+end_src
** Email integration with org-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-notmuch)
#+END_SRC
** org-publish
#+begin_src emacs-lisp :tangle yes
  (defun jethro/auto-git-commit-and-push (dir)
    (shell-command (format "cd %s && git add -A && git commit -m \"%s\" && git push origin master" dir "New changes: $(date)")))

  (setq jethro/emacsd-site-dir "~/Documents/Code/emacsd_site/")

  (setq org-publish-project-alist
        '(("emacs.d"
           :publishing-function org-html-publish-to-html
           :publishing-directory jethro/emacsd-site-dir
           :base-directory "~/.emacs.d/"
           :exclude ".*"
           :include ["init.org"]
           :completion-function (lambda () (let ((htmlfile (concat jethro/emacsd-site-dir
                                                                   "init.html")))
                                             (if (file-exists-p htmlfile)
                                                 (progn
                                                   (rename-file htmlfile
                                                                (concat jethro/emacsd-site-dir
                                                                        "index.html") t)
                                                   (jethro/auto-git-commit-and-push jethro/emacsd-site-dir)))))
           :with-emphasize t
           :with-title nil
           :with-toc t
           :html-head "<link rel=\"stylesheet\" href=\"/css/emacsd.css\" type=\"text/css\">"
           :html-preamble t)))
#+end_src
** org-reveal
#+begin_src emacs-lisp :tangle yes
  (use-package ox-reveal
    :config
    (require 'ox-reveal))
#+end_src
** org-latex
I use export to LaTeX through ox-latex, using xelatex for a nicer export template.
#+begin_src emacs-lisp :tangle yes
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode %f"
          "pdflatex -shell-escape -interaction nonstopmode %f"))
  (require 'ox-latex)
  (setq org-latex-tables-booktabs t)
  (setq org-latex-listings 'minted)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (setq org-latex-minted-options
        '(("frame" "lines")
          ("linenos")
          ("numbersep" "5pt")
          ("framesep" "2mm")
          ("fontfamily" "tt")))
  (add-to-list 'org-latex-classes
               '("book"
                 "\\documentclass[10pt]{memoir}
                        \\usepackage{charter}
                        \\usepackage[T1]{fontenc}
                        \\usepackage{booktabs}
                        \\usepackage{amsmath}
                        \\usepackage{minted}
                        \\usemintedstyle{borland}
                        \\usepackage{color}
                        \\usepackage{epigraph}
                        \\usepackage{enumitem}
                        \\setlist{nosep}
                        \\setlength\\epigraphwidth{13cm}
                        \\setlength\\epigraphrule{0pt}
                        \\usepackage{fontspec}
                        \\usepackage{graphicx}
                        \\usepackage{hyperref}
                        \\hypersetup {colorlinks = true, allcolors = red}
                        \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("books"
                 "\\documentclass[oneside]{tufte-book}
                        \\usepackage{charter}
                        \\usepackage{booktabs}
                        \\usepackage{minted}
                        \\usemintedstyle{bw}
                        \\usepackage{graphicx}

                        \\usepackage{hyperref}
                        \\hypersetup{colorlinks}

                        \\setlength{\\parskip}{1em}

                        \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src
** org-download
#+begin_src emacs-lisp :tangle yes
  (use-package org-download
    :config
    (setq-default org-download-image-dir "./pictures")
    (setq-default org-download-heading-lvl nil)
    (require 'org-download))
#+end_src
** Handling my book collection (deprecated)
*** jethro/org-sort-books
I like to keep my books in sorted order, alphanumerically, and then by TODO keyword.
#+begin_src emacs-lisp :tangle yes
  (defun jethro/org-sort-books ()
      (interactive)
      (let ((old-point (point)))
        (beginning-of-buffer)
        (org-sort-entries t ?a)
        (beginning-of-buffer)
        (org-sort-entries t ?o)
        (show-all)
        (org-global-cycle)
        (goto-char old-point)))
#+end_src
*** jethro/org-after-save-books
#+begin_src emacs-lisp :tangle yes
  (defun jethro/org-after-save-books ()
    (org-publish "books"))
#+end_src
** deft
Deft is similar in many ways to Notational Velocity. I use deft as a brain dump, to quickly collect things I learn or come across.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package deft
    :bind* (("C-c d" . deft)
            ("C-x C-g" . deft-find-file)) 
    :bind (("C-c C-r" . deft-rename-file))
    :config
    (setq deft-directory "~/.org/deft/"
          deft-extensions '("org")
          deft-use-filename-as-title t
          deft-default-extension "org"
          deft-use-filter-string-for-filename t
          deft-file-naming-rules '((noslash . "_")
                                   (nospace . "_")
                                   (case-fn . downcase))))

#+END_SRC
** epresent
#+begin_src emacs-lisp :tangle yes
  (use-package epresent
    :bind ("<f5>"))
#+end_src
* Project Management
** Smerge-mode
Useful when handling git merge conflicts.
#+begin_src emacs-lisp :tangle yes
  (use-package smerge-mode
    :functions smerge-next smerge-prev smerge-keep-all smerge-keep-mine smerge-keep-other
    :config
    (progn
      (global-set-key (kbd "C-c s")
                      (defhydra hydra-smerge (:body-pre (smerge-mode 1) :color red)
                        "Smerge mode"
                        ("<down>" smerge-next        "Next conflict")
                        ("<up>"   smerge-prev        "Previous conflict")
                        ("M-a"    smerge-keep-all    "Keep all")
                        ("M-m"    smerge-keep-mine   "Keep mine")
                        ("M-o"    smerge-keep-other  "Keep other")))))
#+end_src
** Magit
#+begin_src emacs-lisp :tangle yes
  (use-package magit  
    :bind (("s-g" . magit-status)
           ("s-G" . magit-blame))
    :init (setq magit-auto-revert-mode nil)
    :config
    ;; (use-package magithub)
    (add-hook 'magit-mode-hook 'hl-line-mode))
#+end_src

** Projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :demand t
    :init (projectile-global-mode 1)
    :bind-keymap* ("C-x p" . projectile-command-map)
    :config
    (require 'projectile)
    (use-package counsel-projectile 
      :bind (("s-f" . counsel-projectile-find-file)
             ("s-b" . counsel-projectile-switch-to-buffer))
      :config
      (counsel-projectile-on))
    (setq projectile-use-git-grep t)
    (setq projectile-create-missing-test-files t)
    (setq projectile-completion-system 'ivy))
#+end_src

*** Projectile Commander
#+begin_src emacs-lisp :tangle yes
  (setq projectile-switch-project-action
        #'projectile-commander)
  (def-projectile-commander-method ?s
    "Open a *eshell* buffer for the project."
    (projectile-run-eshell))
  (def-projectile-commander-method ?c
    "Run `compile' in the project."
    (projectile-compile-project nil))
  (def-projectile-commander-method ?\C-?
    "Go back to project selection."
    (projectile-switch-project))
  (def-projectile-commander-method ?d
    "Open project root in dired."
    (projectile-dired))
  (def-projectile-commander-method ?F
    "Git fetch."
    (magit-status)
    (call-interactively #'magit-fetch-all))
  (def-projectile-commander-method ?j
    "Jack-in."
    (let* ((opts (projectile-current-project-files))
           (file (ivy-read
                  "Find file: " 
                  opts)))
      (find-file (expand-file-name
                  file (projectile-project-root)))
      (run-hooks 'projectile-find-file-hook)
      (cider-jack-in)))
#+end_src
* Profiling
** esup
#+begin_src emacs-lisp :tangle yes
(use-package esup
  :defer t)
#+end_src
** keyfreq
#+begin_src emacs-lisp :tangle yes
(use-package keyfreq
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+end_src
* Miscellaneous
** Pivotal-mode
#+begin_src emacs-lisp :tangle no
  (use-package pivotal-tracker
    :config
    (setq pivotal-api-token jethro/pivotal-api-token))
#+end_src
** which-key
#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :diminish which-key-mode
  :config (add-hook 'after-init-hook 'which-key-mode))
#+end_src
** nameless
#+begin_src emacs-lisp :tangle yes
(use-package nameless
  :diminish nameless-mode
  :config
  (add-hook 'emacs-lisp-mode-hook 'nameless-mode-from-hook)
  (setq nameless-global-aliases
        '(("fl" . "font-lock")
          ("s" . "seq")
          ("me" . "macroexp")
          ("c" . "cider")
          ("q" . "queue"))))
#+end_src
** firestarter
#+begin_src emacs-lisp :tangle yes
(use-package firestarter
  :bind ("C-c M s" . firestarter-mode)
  :init (put 'firestarter 'safe-local-variable 'identity))
#+end_src
** Paradox
Use Paradox instead of the default =package-list-packages=. =jethro/paradox-user-token= is defined in =secrets.el=, and contains a github API token which has =public_repo= permissions.
#+begin_src emacs-lisp :tangle yes
(use-package paradox
  :commands (paradox-list-packages)
  :config
  (setq paradox-github-token jethro/paradox-user-token))
#+end_src
** focus
#+begin_src emacs-lisp :tangle yes
(use-package focus
  :diminish focus-mode
  :bind ("C-c M f" . focus-mode))
#+end_src
** artbollocks
Prevent usage of passive voice, weasel words and other common grammatical mistakes.
#+begin_src emacs-lisp :tangle yes
(use-package artbollocks-mode
  :bind (("C-c M a" . artbollocks-mode))
  :config
  (add-hook 'text-mode-hook 'artbollocks-mode))
#+end_src
** darkroom
#+begin_src emacs-lisp :tangle yes
(use-package darkroom
  :bind (("C-c M d" . darkroom-mode)
         ("C-c M t" . darkroom-tentative-mode)))
#+end_src
** bury-successful-compilation
Closes compile buffer if there are no errors.
#+begin_src emacs-lisp :tangle yes
(use-package bury-successful-compilation
  :config
  (bury-successful-compilation 1))
#+end_src
** Spotify
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package spotify)
#+END_SRC
* Tangling                                                         :noexport:
#+begin_src emacs-lisp :tangle no
  (org-babel-tangle)
#+end_src

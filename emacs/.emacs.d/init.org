#+TITLE: Jethro's Emacs.d Configuration
* Introduction
* Basic Setup
** Add MELPA and Org Repository
Add package archives. Note that I'm using HTTP, HTTPS did not work for me. To configure HTTPS, simply replace occurrences of http with https.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (package-initialize))
#+END_SRC

** Add [[https://github.com/jwiegley/use-package/issues/70][use-package]]
Use-package allows for isolation of package configuration, while maintaining tidiness and performance.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-and-compile
  (defvar use-package-verbose t) 
  (require 'cl)
  (require 'use-package)
  (require 'bind-key)
  (require 'diminish)
  (setq use-package-always-ensure t))
#+END_SRC

** Add validate
Validate is a package that checks for and reports Emacs config errors.
#+begin_src emacs-lisp :tangle yes
  (use-package validate
    :demand t)
#+end_src
** User configuration
** 
#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Jethro Kuan"
      user-mail-address "jethrokuan95@gmail.com")
#+end_src

** Custom file
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC
** Default browser
#+begin_src emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-firefox
        browse-url-new-window-flag  t
        browse-url-firefox-new-window-is-tab t)
#+end_src
** Custom font
I use Hack, patched with Powerline. Other good alternatives include Source Code Pro.
*** Source Code Pro
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'default-frame-alist
             '(font . "Inconsolata-12"))
#+END_SRC

** UI Cruft
Remove useless toolbars and splash screens.

#+begin_src emacs-lisp :tangle yes
(tooltip-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
#+end_src

** Use y/n over yes/no
Always prefer the shorter y/n over yes/no.

#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Replace region when typing
Type over a selected region, instead of deleting before typing.

#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode +1)
#+end_src

** Sentences
Emacs uses double-spaces by default. Use single spaces by default:

#+BEGIN_QUOTE
NOTE: This will cause an indistinction between sentences and name abbrieviations (eg. E. B. White)
#+END_QUOTE

#+begin_src emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+end_src

** Tab with 2 spaces
#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 2)
(setq-default js-indent-level 2)
(setq-default indent-tabs-mode nil)
#+end_src

** Don't wrap lines
Don't wrap lines for coding. Create a hook that enables wrapping, for modes like org-mode and markdown-mode.

#+begin_src emacs-lisp :tangle yes
(setq-default truncate-lines t)
(defun trunc-lines-hook ()
  (setq truncate-lines nil))
#+end_src

** Backup directory
#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

The following code will delete all backup files that are older than a certain date:

#+begin_src emacs-lisp :tangle yes
(message "Deleting old backup files...")
(let ((week (* 60 60 24 7))
      (current (float-time (current-time))))
  (dolist (file (directory-files temporary-file-directory t))
    (when (and (backup-file-name-p file)
               (> (- current (float-time (fifth (file-attributes file))))
                  week))
      (message "%s" file)
      (delete-file file))))
#+end_src
** Load secrets
#+begin_src emacs-lisp :tangle yes
(load "~/.emacs.d/secrets.el" t)
#+end_src
** Add PATH to eshell
#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :demand t
  :init (exec-path-from-shell-initialize))
#+end_src

** Default shell
#+begin_src emacs-lisp :tangle yes
  (setq-default explicit-shell-file-name "/bin/bash")
  (setq-default shell-file-name "/bin/bash")
#+end_src
** Theme
*** Doom Theme
#+begin_src emacs-lisp :tangle no
  (use-package doom-themes
    :init
    (load-theme 'doom-one t)
    :config
    (add-hook 'find-file-hook 'doom-buffer-mode)
    (add-hook 'minibuffer-setup-hook 'doom-brighten-minibuffer)
    (require 'doom-neotree)
    (setq doom-enable-brighter-comments t)
    (use-package all-the-icons))
#+end_src
*** Theme-less
**** Set background
 #+begin_src emacs-lisp :tangle no
   (add-to-list 'default-frame-alist '(background-color . "ivory"))
   (set-face-attribute 'region nil :background "salmon")
 #+end_src
*** Creamsody Theme
#+begin_src emacs-lisp :tangle no
  (use-package creamsody-theme
    :init
    (load-theme 'creamsody t)
    :config
    (creamsody-modeline))
#+end_src
** Keybindings
*** Opening Lines
#+begin_src emacs-lisp :tangle yes
  (defun open-next-line (arg)
    "Move to the next line and then opens a line.
     See also `newline-and-indent'."
    (interactive "p")
    (end-of-line)
    (open-line arg)
    (next-line 1)
    (when 'newline-and-indent
      (indent-according-to-mode)))

  (defun open-previous-line (arg)
    "Open a new line before the current one. 
       See also `newline-and-indent'."
    (interactive "p")
    (beginning-of-line)
    (open-line arg)
    (when 'newline-and-indent
      (indent-according-to-mode)))

  (bind-key* "C-o" 'open-next-line)
  (bind-key* "M-o" 'open-previous-line)
#+end_src
*** Nuke all buffers with =C-c !=
#+begin_src emacs-lisp :tangle yes
  (defun jethro/nuke-all-buffers ()
    (interactive)
    (mapcar 'kill-buffer (buffer-list))
    (delete-other-windows))

  (bind-key* "C-c !" 'jethro/nuke-all-buffers)
#+end_src
*** eshell with =C-x m=
#+begin_src emacs-lisp :tangle yes
  (bind-key* "C-x m" 'eshell)
#+end_src
*** mark-paragraph with =M-p=
#+begin_src emacs-lisp :tangle yes
  (bind-key* "M-p" 'mark-paragraph)
#+end_src
*** compile with =<f9>=
#+begin_src emacs-lisp :tangle yes
  (bind-key* "<f9>" (lambda ()
                      (interactive)
                      (setq-local compilation-read-command nil)
                      (call-interactively 'compile)))
#+end_src
**** 
** Hydra
#+begin_src emacs-lisp :tangle yes
  (use-package hydra)
#+end_src
*** Ample Theme
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ample-theme
    :init
    (load-theme 'ample t))
#+END_SRC
* Mail (notmuch)
** Basic Setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package notmuch
    :bind (("<f10>" . notmuch)))
#+END_SRC
** Goobook
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'notmuch-address)
  (setq notmuch-address-command "~/.emacs.d/goobook")
  (notmuch-address-message-insinuate)
#+END_SRC
* Ivy
I've recently switched over from =helm= to =ivy=. Ivy is simpler, and easier to extend.
** flx
Flx is required for fuzzy-matching.
#+begin_src emacs-lisp :tangle yes
(use-package flx)
#+end_src
** Counsel
Counsel contains ivy enhancements for commonly-used functions.
#+begin_src emacs-lisp :tangle yes
  (use-package counsel
    :demand t
    :bind*
    (("C-c C-r" . ivy-resume)
     ("M-a" . counsel-M-x)
     ("C-M-i" . counsel-imenu)
     ("C-x C-f" . counsel-find-file)
     ("C-x j" . counsel-dired-jump)
     ("C-x l" . counsel-locate)
     ("C-c j" . counsel-git-grep)
     ("C-c k" . counsel-ag) 
     ("M-y" . counsel-yank-pop))
    :bind (:map help-map
                ("f" . counsel-describe-function)
                ("v" . counsel-describe-variable)
                ("l" . counsel-info-lookup-symbol))
    :config
    (ivy-mode 1)
    (setq counsel-find-file-at-point t)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (setq ivy-initial-inputs-alist nil)
    (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done))
#+end_src
** Swiper
Swiper is ivy-enhanced isearch.
#+begin_src emacs-lisp :tangle no
  (use-package swiper
    :bind*
    (("C-s" . swiper)
     ("C-r" . swiper)
     ("C-M-s" . swiper-all))
    :bind
    (:map read-expression-map
          ("C-r" . counsel-expression-history)))
#+end_src
** Fuzzy Searching
#+begin_src emacs-lisp :tangle yes
  (setq ivy-re-builders-alist
        '((ivy-switch-buffer . ivy--regex-plus)
          (swiper . ivy--regex-plus)
          (t . ivy--regex-fuzzy)))
#+end_src
** Ivy custom actions
#+begin_src emacs-lisp :tangle yes
  (define-key ivy-minibuffer-map (kbd "C-:") 'ivy-dired)
  (define-key ivy-minibuffer-map (kbd "C-c o") 'ivy-occur)
  (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
  (ivy-set-actions
   t
   '(("I" insert "insert")))
#+end_src
*** Ivy-dired
#+begin_src emacs-lisp :tangle yes
  (defun ivy-dired ()
    (interactive)
    (if ivy--directory
        (ivy-quit-and-run
         (dired ivy--directory)
         (when (re-search-forward
                (regexp-quote
                 (substring ivy--current 0 -1)) nil t)
           (goto-char (match-beginning 0))))
      (user-error
       "Not completing files currently")))

  (define-key ivy-minibuffer-map (kbd "C-:") 'ivy-dired)
#+end_src 
* Moving Around
** GTD files
#+begin_src emacs-lisp :tangle yes
  (setq jethro/org-files "~/.org/")

  (defun jethro/find-org-file (file-str) 
    (find-file (concat (file-name-directory jethro/org-files) file-str)))

  (defun jethro/find-work-file ()
    (interactive)
    (jethro/find-org-file "work.org"))

  (defun jethro/find-school-file ()
    (interactive)
    (jethro/find-org-file "school.org"))

  (bind-key* "<f1> w" 'jethro/find-work-file)
  (bind-key* "<f1> s" 'jethro/find-school-file)
#+end_src
** neotree
#+begin_src emacs-lisp :tangle yes
  (use-package neotree)
#+end_src
** Crux
#+begin_src emacs-lisp :tangle yes
  (use-package crux
    :commands (crux-switch-to-previous-buffer)
    :bind* (("C-c o" . crux-open-with)
            ("C-c n" . crux-cleanup-buffer-or-region)
            ("C-c D" . crux-delete-file-and-buffer)
            ("C-a" . crux-move-beginning-of-line)
            ("M-o" . crux-smart-open-line)
            ("C-c r" . crux-rename-file-and-buffer)
            ("M-d" . crux-duplicate-current-line-or-region)
            ("M-D" . crux-duplicate-and-comment-current-line-or-region)
            ("s-o" . crux-smart-open-line-above)))
#+end_src
** avy
Use avy to move between visible text.
#+begin_src emacs-lisp :tangle yes

  (use-package avy
    :bind* (("C-'" . avy-goto-char)
            ("C-," . avy-goto-char-2))
    :config
    (setq avy-keys '(?h ?t ?n ?s)))
#+end_src
** dumb-jump
Use it to jump to function definitions. Requires no external depedencies.
#+begin_src emacs-lisp :tangle yes
(use-package dumb-jump
  :diminish dumb-jump-mode
  :bind (("C-M-g" . dumb-jump-go)
         ("C-M-p" . dumb-jump-back)
         ("C-M-q" . dumb-jump-quick-look)))
#+end_src
** Window switching
#+begin_src emacs-lisp :tangle yes
  (use-package windmove
    ;; :defer 4
    :ensure t
    :config
    ;; use command key on Mac
    (windmove-default-keybindings 'super)
    ;; wrap around at edges
    (setq windmove-wrap-around t))
#+end_src
** ace-window (disabled)
Ace-window makes it easier to move between windows.
#+begin_src emacs-lisp :tangle no
  (use-package ace-window
    :bind ("M-'" . ace-window)
    :config
    (setq aw-keys '(?h ?t ?n ?s)))
#+end_src
** dired
*** Hide details
Hide details and only show file and folder names.
#+begin_src emacs-lisp :tangle yes
  (defun jethro/dired-mode-setup-hook ()
    "hook for dired-mode"
    (dired-hide-details-mode 1))

  (add-hook 'dired-mode-hook 'jethro/dired-mode-setup-hook)
#+end_src
*** Sort directories first
#+begin_src emacs-lisp :tangle yes
(setq dired-listing-switches "-aBhl  --group-directories-first")
#+end_src
*** Recursive Copying and Deleting
#+begin_src emacs-lisp :tangle yes
  (setq dired-recursive-copies (quote always))
  (setq dired-recursive-deletes (quote top))
#+end_src
*** dired-jump from file
#+begin_src emacs-lisp :tangle yes
  (require 'dired-x)
#+end_src
** save-place-mode
Save the cursor location for files I've visited.
#+begin_src emacs-lisp :tangle yes
  (save-place-mode 1)
#+end_src
** key-chord
#+begin_src emacs-lisp :tangle yes
  (use-package key-chord
    :config
    (key-chord-mode 1)
    (key-chord-define-global "mw" 'avy-goto-word-1)   
    (key-chord-define-global "jk" 'avy-goto-char)
    (key-chord-define-global "JJ" 'crux-switch-to-previous-buffer)
    (key-chord-define-global "FF" 'counsel-find-file)
    (key-chord-define-global "xx" 'execute-extended-command)
    (key-chord-define-global "yy" 'counsel-yank-pop)
    (key-chord-define-global ",." 'neotree-toggle))
#+end_src
* Editing Text
** visual-regexp
#+begin_src emacs-lisp :tangle yes
  (use-package visual-regexp
    :bind* (("C-M-%" . vr/query-replace)
            ("C-c m" . vr/mc-mark)))
#+end_src
** electric-pair mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'after-init-hook (lambda () (electric-pair-mode 1)))
#+end_src
** electric-align
Use multiple spaces to align code and text.
#+begin_src emacs-lisp :tangle yes
(use-package electric-align
  :ensure f
  :load-path "elisp/"
  :diminish electric-align-mode
  :config (add-hook 'prog-mode-hook 'electric-align-mode))
#+end_src
** aggressive-indent
Keep your text indented at all times. Remember to turn this off for indentation-dependent languages like Python and Haml.
#+begin_src emacs-lisp :tangle yes
(use-package aggressive-indent
  :diminish aggressive-indent-mode
  :config (add-hook 'prog-mode-hook 'aggressive-indent-mode))
#+end_src
** multiple-cursors
A port of Sublime Text's multiple-cursors functionality.
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("C-M-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+end_src
** expand-region
Use this often, and in combination with multiple-cursors.
#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :bind (("C-=" . er/expand-region)))
#+end_src
** iedit
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package iedit)
#+END_SRC
** paredit
For editing Lisp code.
#+begin_src emacs-lisp :tangle no
(use-package paredit
  :diminish paredit-mode
  :config
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'clojure-mode-hook 'paredit-mode))
#+end_src
** smartparens
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :bind (:map smartparens-mode-map
                ("C-M-a" . sp-beginning-of-sexp)
                ("C-M-e" . sp-end-of-sexp)

                ("C-<down>" . sp-down-sexp)
                ("C-<up>"   . sp-up-sexp)
                ("M-<down>" . sp-backward-down-sexp)
                ("M-<up>"   . sp-backward-up-sexp)

                ("C-M-f" . sp-forward-sexp)
                ("C-M-b" . sp-backward-sexp)

                ("C-M-n" . sp-next-sexp)
                ("C-M-p" . sp-previous-sexp)

                ("C-S-f" . sp-forward-symbol)
                ("C-S-b" . sp-backward-symbol)

                ("C-<right>" . sp-forward-slurp-sexp)
                ("M-<right>" . sp-forward-barf-sexp)
                ("C-<left>"  . sp-backward-slurp-sexp)
                ("M-<left>"  . sp-backward-barf-sexp)

                ("C-M-t" . sp-transpose-sexp)
                ("C-M-k" . sp-kill-sexp)
                ("C-k"   . sp-kill-hybrid-sexp)
                ("M-k"   . sp-backward-kill-sexp)
                ("C-M-w" . sp-copy-sexp)

                ("C-M-d" . delete-sexp)

                ("M-<backspace>" . backward-kill-word)
                ("C-<backspace>" . sp-backward-kill-word)
                ([remap sp-backward-kill-word] . backward-kill-word)

                ("M-[" . sp-backward-unwrap-sexp)
                ("M-]" . sp-unwrap-sexp)

                ("C-x C-t" . sp-transpose-hybrid-sexp)

                ("M-c ("  . wrap-with-parens)
                ("M-c ["  . wrap-with-brackets)
                ("M-c {"  . wrap-with-braces)
                ("M-c '"  . wrap-with-single-quotes)
                ("M-c \"" . wrap-with-double-quotes)
                ("M-c _"  . wrap-with-underscores)
                ("M-c `"  . wrap-with-back-quotes)) 
    :init
    (add-hook 'emacs-lisp-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'clojure-mode-hook 'turn-on-smartparens-strict-mode)
    :config
    (require 'smartparens-config)
    (defmacro def-pairs (pairs)
      `(progn
         ,@(loop for (key . val) in pairs
                 collect
                 `(defun ,(read (concat
                                 "wrap-with-"
                                 (prin1-to-string key)
                                 "s"))
                      (&optional arg)
                    (interactive "p")
                    (sp-wrap-with-pair ,val)))))

    (def-pairs ((paren        . "(")
                (bracket      . "[")
                (brace        . "{")
                (single-quote . "'")
                (double-quote . "\"")
                (back-quote   . "`"))))
#+end_src
** zap-up-to-char
#+begin_src emacs-lisp :tangle yes
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR.

    \(fn arg char)"
    'interactive)

  (bind-key* "M-z" 'zap-up-to-char)
#+end_src
** move-text
#+begin_src emacs-lisp :tangle yes
  (use-package move-text
    :bind (("M-<up>" . move-text-up)
           ("M-<down>" . move-text-down)))
#+end_src
** Linting with Flycheck
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :config
    (global-set-key (kbd "C-c f")
                    (defhydra hydra-flycheck
                      (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
                            :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
                            :hint nil)
                      "Errors"
                      ("f"  flycheck-error-list-set-filter                            "Filter")
                      ("n"  flycheck-next-error                                       "Next")
                      ("p"  flycheck-previous-error                                   "Previous")
                      ("<" flycheck-first-error                                      "First")
                      (">"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
                      ("q"  nil)))
    (use-package flycheck-pos-tip
      :config (flycheck-pos-tip-mode))
    (add-hook 'prog-mode-hook 'global-flycheck-mode))
#+end_src
** Templating with Yasnippet
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish yas-global-mode yas-minor-mode
    :init (add-hook 'after-init-hook 'yas-global-mode)
    :config (setq yas-snippet-dirs '("~/.emacs.d/snippets/")))
#+end_src
** Autocompletions with Company
#+begin_src emacs-lisp :tangle yes
(use-package company
  :diminish company-mode
  :init (progn
          (add-hook 'after-init-hook 'global-company-mode)
          (setq company-dabbrev-ignore-case nil
                company-dabbrev-code-ignore-case nil
                company-dabbrev-downcase nil
                company-idle-delay 0
                company-begin-commands '(self-insert-command)
                company-transformers '(company-sort-by-occurrence))
          (use-package company-quickhelp
            :config (company-quickhelp-mode 1))))
#+end_src
** Spellcheck with Flyspell
#+begin_src emacs-lisp :tangle yes
  (use-package flyspell 
    :ensure f 
    :diminish flyspell-mode
    :init
    (setenv "DICTIONARY" "en_GB")
    :config   
    (add-hook 'markdown-mode-hook 'flyspell-mode))
#+end_src
* Language Support
** Common Lisp
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package slime
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))
#+END_SRC
** Emacs Lisp
#+begin_src emacs-lisp :tangle yes
  (bind-key "C-c C-k" 'eval-buffer emacs-lisp-mode-map)
#+end_src
** Go
#+begin_src emacs-lisp :tangle yes
(use-package go-mode
  :mode ("\\.go\\'" . go-mode)
  :config (progn
            (add-hook 'go-mode-hook 'compilation-auto-quit-window)
            (add-hook 'go-mode-hook (lambda ()
                                      (set (make-local-variable 'company-backends) '(company-go))
                                      (company-mode)))
            (add-hook 'go-mode-hook (lambda ()
                                      (add-hook 'before-save-hook 'gofmt-before-save)
                                      (local-set-key (kbd "M-.") 'godef-jump)))
            (add-hook 'go-mode-hook
                      (lambda ()
                        (unless (file-exists-p "Makefile")
                          (set (make-local-variable 'compile-command)
                               (let ((file (file-name-nondirectory buffer-file-name)))
                                 (format "go build %s"
                                         file))))))
            (use-package go-dlv
              :config (require 'go-dlv))
            (use-package golint
              :config
              (add-to-list 'load-path (concat (getenv "GOPATH")  "/src/github.com/golang/lint/misc/emacs"))
              (require 'golint))
            (use-package gorepl-mode
              :config (add-hook 'go-mode-hook #'gorepl-mode))
            (use-package company-go
              :config (add-hook 'go-mode-hook (lambda ()
                                                (set (make-local-variable 'company-backends) '(company-go))
                                                (company-mode))))))
#+end_src
** C++
*** C++ compile function
#+begin_src emacs-lisp :tangle yes
(add-hook 'c++-mode-hook
          (lambda ()
            (unless (file-exists-p "Makefile")
              (set (make-local-variable 'compile-command)
                   (let ((file (file-name-nondirectory buffer-file-name)))
                     (format "g++ -Wall -s -pedantic-errors %s -o %s --std=c++14"
                             file
                             (file-name-sans-extension file)))))))
#+end_src
** Java
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eclim
    :config 
    (global-eclim-mode))
#+END_SRC
*** company-emacs-eclim
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-emacs-eclim
    :config
    (company-emacs-eclim-setup))
#+END_SRC
*** gradle
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gradle-mode
    :config
    (add-hook 'java-mode-hook (lambda ()
                                (gradle-mode 1))))

#+END_SRC
** Fish
#+begin_src emacs-lisp :tangle yes
  (use-package fish-mode
    :mode ("\\.fish\\'" . fish-mode)
    :init (add-hook 'fish-mode-hook
                    (lambda () (aggressive-indent-mode -1))))
#+end_src
** Rust
#+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
#+end_src
** Python
#+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :mode ("\\.py\\'" . elpy-mode)
    :init
    (add-hook 'python-mode-hook (lambda () (aggressive-indent-mode -1)))
    :config
    (when (require 'flycheck nil t)
      (remove-hook 'elpy-modules 'elpy-module-flymake)
      (remove-hook 'elpy-modules 'elpy-module-yasnippet)
      (remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
      (add-hook 'elpy-mode-hook 'flycheck-mode))
    (elpy-enable)
    (setq elpy-rpc-backend "jedi"))
#+end_src
** HTML
*** Web-mode
 #+begin_src emacs-lisp :tangle yes
   (use-package web-mode
     :mode (("\\.html\\'" . web-mode)
            ("\\.html\\.erb\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.jinja\\'" . web-mode)
            ("\\.njk\\'" . web-mode)
            ("\\.php\\'" . web-mode))
     :config
     (setq web-mode-enable-css-colorization t)
     (setq web-mode-code-indent-offset 2)
     (setq web-mode-markup-indent-offset 2))
 #+end_src
*** Emmet-mode
 #+begin_src emacs-lisp :tangle yes
(use-package emmet-mode
  :diminish emmet-mode
  :config
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'vue-mode-hook 'emmet-mode))
 #+end_src
** CSS
*** Rainbow-mode
 #+begin_src emacs-lisp :tangle yes
   (use-package rainbow-mode
     :diminish rainbow-mode
     :config
     (add-hook 'css-mode-hook 'rainbow-mode)
     (add-hook 'scss-mode-hook 'rainbow-mode))
 #+end_src
*** SCSS-mode
 #+begin_src emacs-lisp :tangle yes
 (use-package scss-mode
   :mode "\\.scss\\'" 
   :config (progn
             (setq scss-compile-at-save nil)))
 #+end_src
** JS
*** Flycheck
#+begin_src emacs-lisp :tangle yes
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (flycheck-add-mode 'javascript-eslint 'web-mode)
#+end_src
*** Skewer
#+begin_src emacs-lisp :tangle yes
  (use-package skewer-mode  
    :bind (:map skewer-mode-map
                ("C-c C-k" . skewer-load-buffer))
    :config
    (add-hook 'js2-mode-hook 'skewer-mode))
#+end_src
*** js-comint
#+begin_src emacs-lisp :tangle no
  (use-package js-comint
    :config
    (add-hook 'js2-mode-hook
              (lambda ()
                (local-set-key (kbd "C-x C-e") 'js-send-last-sexp)
                (local-set-key (kbd "C-M-x") 'js-send-last-sexp-and-go)
                (local-set-key (kbd "C-c b") 'js-send-buffer)
                (local-set-key (kbd "C-c C-b") 'js-send-buffer-and-go)
                (local-set-key (kbd "C-c l") 'js-load-file-and-go))))
#+end_src
*** JS2-mode

Here I also added =tern-mode=. This requires the tern executable:
#+begin_src bash :tangle no
npm install -g tern
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package js2-mode
    :mode ("\\.js\\'" . js2-mode)
    :config
    (use-package tern
      :diminish tern-mode
      :config    
      (add-hook 'js2-mode-hook 'tern-mode)
      (use-package company-tern
        :config
        (add-to-list 'company-backends 'company-tern))))
#+end_src
*** JS2-refactor
#+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-j"))
#+end_src
*** Jade
#+begin_src emacs-lisp :tangle yes
(use-package jade)
#+end_src
*** Vue-mode
Additional support for Vue.js projects.

 #+begin_src emacs-lisp :tangle yes
 (use-package vue-mode
   :mode "\\.vue\\'")
 #+end_src
** JSON
 #+begin_src emacs-lisp :tangle yes
 (use-package json-mode
   :mode "\\.json\\'"
   :config (add-hook 'json-mode-hook (lambda ()
                                       (make-local-variable 'js-indent-level)
                                       (setq js-indent-level 2))))
 #+end_src
** Markdown
#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :config (progn
            (setq markdown-command "multimarkdown")
            (add-hook 'markdown-mode-hook #'trunc-lines-hook)))
#+end_src
** Clojure
*** Clojure-mode
#+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode
    :mode (("\\.clj\\'" . clojure-mode)
           ("\\.boot\\'" . clojure-mode)
           ("\\.edn\\'" . clojure-mode)
           ("\\.cljs\\'" . clojurescript-mode)
           ("\\.cljs\\.hl\\'" . clojurescript-mode))
    :init
    (add-hook 'clojure-mode-hook #'eldoc-mode)
    (add-hook 'clojure-mode-hook #'subword-mode)
    (add-hook 'clojure-mode-hook #'cider-mode)
    (add-hook 'clojure-mode-hook #'clj-refactor-mode))
#+end_src
*** Cider
#+begin_src emacs-lisp :tangle yes
  (use-package cider
    :init
    (add-hook 'cider-mode-hook #'clj-refactor-mode)
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode)
    :diminish subword-mode
    :config
    (setq nrepl-log-messages t                  
          cider-repl-display-in-current-window t
          cider-repl-use-clojure-font-lock t    
          cider-prompt-save-file-on-load 'always-save
          cider-font-lock-dynamically '(macro core function var)
          nrepl-hide-special-buffers t
          cider-show-error-buffer nil
          cider-overlays-use-font-lock t
          cider-repl-result-prefix ";; => ")
    (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
    (cider-repl-toggle-pretty-printing))
#+end_src
*** clj-refactor
#+begin_src emacs-lisp :tangle yes
(use-package clj-refactor
  :defines cljr-add-keybindings-with-prefix
  :diminish clj-refactor-mode
  :config (cljr-add-keybindings-with-prefix "C-c C-j"))
#+end_src
*** Squiggly-clojure
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck-clojure
    :config
    (flycheck-clojure-setup))
#+end_src
* Visual Enhancements
** linum-mode (Disabled)
#+begin_src emacs-lisp :tangle no
(add-hook 'prog-mode-hook 
  (lambda ()
    (linum-mode 1)))
#+end_src
** hl-line-mode
#+begin_src emacs-lisp :tangle yes
(global-hl-line-mode 1)
#+end_src
** whitespace-mode
Show fill-column.
#+begin_src emacs-lisp :tangle yes
(require 'whitespace)
(setq whitespace-line-column 80) ;; limit line length
(setq whitespace-style '(face lines-tail))

(add-hook 'prog-mode-hook 'whitespace-mode)
#+end_src
** Page-break-lines
#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines)
#+end_src
** Smart-mode-line
#+begin_src emacs-lisp :tangle yes
  (use-package smart-mode-line
    :config
    (add-hook 'after-init-hook 'sml/setup)
    (setq sml/name-width 30)
    (setq sml/shorten-directory t)
    (setq sml/shorten-modes t)
    (setq sml/mode-width 'full)
    (setq sml/replacer-regexp-list
          '(("^~/.org/" ":O:")
            ("^~/\\.emacs\\.d/" ":ED")))
    (setq rm-blacklist
          (format "^ \\(%s\\)$"
                  (mapconcat #'identity
                             '("FlyC.*"
                               "Projectile.*"
                               "GitGutter"
                               "ivy"
                               "company"
                               ""
                               "doom"
                               ","
                               "ElDoc")
                             "\\|"))))
#+end_src
*** Showing time
#+begin_src emacs-lisp :tangle yes
(setq display-time-24hr-format t)
(display-time-mode 1)
#+end_src
** nyan-mode
#+begin_src emacs-lisp :tangle no
  (use-package nyan-mode
    :config
    (nyan-mode 1))
#+end_src
** Zooming
#+begin_src emacs-lisp :tangle yes
(defhydra hydra-zoom (global-map "<f2>")
  "zoom"
  ("i" text-scale-increase "in")
  ("o" text-scale-decrease "out"))
#+end_src
** beacon
Beacon makes sure you don't lose track of your cursor when jumping around a buffer.
#+begin_src emacs-lisp :tangle yes
  (use-package beacon
    :diminish beacon-mode
    :config
    (beacon-mode 1)
    (setq beacon-push-mark 10))
#+end_src
** show-paren
Always show matching parenthesis.
#+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)
(setq show-paren-delay 0)
#+end_src
** golden-ratio
Give the working window more screen estate.
#+begin_src emacs-lisp :tangle yes
(use-package golden-ratio
  :diminish golden-ratio-mode
  :config (progn
            (add-to-list 'golden-ratio-extra-commands 'ace-window)
            (golden-ratio-mode 1)))
#+end_src
** volatile-highlights
Highlights recently copied/pasted text.
#+begin_src emacs-lisp :tangle yes
(use-package volatile-highlights
  :diminish volatile-highlights-mode
  :config (volatile-highlights-mode t))
#+end_src
** git-gutter-fringe+
Displays added/modified/deleted on the left.
#+begin_src emacs-lisp :tangle yes
  (use-package git-gutter-fringe+
    :config
    (global-git-gutter+-mode)
    (set-face-foreground 'git-gutter+-modified "gold1")
    (set-face-foreground 'git-gutter+-added    "SeaGreen")
    (set-face-foreground 'git-gutter+-deleted  "IndianRed")
    (setq git-gutter-fr+-side 'left-fringe))
#+end_src
* Org-mode
** Getting Started
   :PROPERTIES:
   :CUSTOM_ID: GettingStarted
   :END:

 Getting started with =org-mode= is really easy.  You only need a few lines in your
 emacs startup to use the latest version of org-mode from the =git= repository.
*** Org-Mode Setup
    :PROPERTIES:
    :CUSTOM_ID: Setup
    :END:

 #+header: :tangle yes
 #+begin_src emacs-lisp :exports none
   (use-package org-plus-contrib
     :bind (("C-c l" . org-store-link)
            ("C-c a" . org-agenda)
            ("C-c b" . org-iswitchb)
            ("C-c c" . org-capture))
     :config
     (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode)))
 #+end_src

 That's all you need to get started using headlines and lists in org-mode.

 The rest of this document describes customizations I use in my setup,
 how I structure org-mode files, and other changes to fit the way I
 want org-mode to work.
*** Agenda Setup
 #+begin_src emacs-lisp :tangle yes
   (setq org-agenda-files (file-expand-wildcards "~/.org/gtd/*.org"))
 #+end_src

*** Org File Structure
    :PROPERTIES:
    :CUSTOM_ID: OrgFileStructure
    :END:

 Most of my org files are set up with level 1 headings as main
 categories only.  Tasks and projects normally start as level 2.

 Here are some examples of my level 1 headings in

 =todo.org=:

 - Special Dates

   Includes level 2 headings for

   - Birthdays
   - Anniversaries
   - Holidays

 - Finances
 - Health and Recreation
 - House Maintenance
 - Lawn and Garden Maintenance
 - Notes
 - Tasks
 - Vehicle Maintenance
 - Passwords


 =norang.org=:

 - System Maintenance
 - Payroll
 - Accounting
 - Finances
 - Hardware Maintenance
 - Tasks
 - Research and Development
 - Notes
 - Purchase Order Tracking
 - Passwords

 Each of these level 1 tasks normally has a =property drawer=
 specifying the category for any tasks in that tree.  Level 1 headings
 are set up like this:

 #+begin_src org :exports src
 ,* Health and Recreation
   :PROPERTIES:
   :CATEGORY: Health
   :END:
   ...
 ,* House Maintenance
   :PROPERTIES:
   :CATEGORY: House
   :END:
 #+end_src
*** Key bindings
    :PROPERTIES:
    :CUSTOM_ID: KeyBindings
    :END:

 I live in the agenda.  To make getting to the agenda faster I mapped
 =F12= to the sequence =C-c a= since I'm using it hundreds of times a
 day.

 I have the following custom key bindings set up for my emacs (sorted by frequency).

 | Key     | For                                             | Used       |
 |---------+-------------------------------------------------+------------|
 | F12     | Agenda (1 key less than C-c a)                  | Very Often |
 | C-c b   | Switch to org file                              | Very Often |
 | F11     | Goto currently clocked item                     | Very Often |
 | C-c c   | Capture a task                                  | Very Often |
 | C-F11   | Clock in a task (show menu with prefix)         | Often      |
 | f9 g    | Gnus - I check mail regularly                   | Often      |
 | f5      | Show todo items for this subtree                | Often      |
 | S-f5    | Widen                                           | Often      |
 | f9 b    | Quick access to bbdb data                       | Often      |
 | f9 c    | Calendar access                                 | Often      |
 | C-S-f12 | Save buffers and publish current project        | Often      |
 | C-c l   | Store a link for retrieval with C-c C-l         | Often      |
 | f8      | Go to next org file in org-agenda-files         | Sometimes  |
 | f9 r    | Boxquote selected region                        | Sometimes  |
 | f9 t    | Insert inactive timestamp                       | Sometimes  |
 | f9 v    | Toggle visible mode (for showing/editing links) | Sometimes  |
 | C-f9    | Previous buffer                                 | Sometimes  |
 | C-f10   | Next buffer                                     | Sometimes  |
 | C-x n r | Narrow to region                                | Sometimes  |
 | f9 f    | Boxquote insert a file                          | Sometimes  |
 | f9 i    | Info manual                                     | Sometimes  |
 | f9 I    | Punch Clock In                                  | Sometimes  |
 | f9 O    | Punch Clock Out                                 | Sometimes  |
 | f9 o    | Switch to org scratch buffer                    | Sometimes  |
 | f9 s    | Switch to scratch buffer                        | Sometimes  |
 | f9 h    | Hide other tasks                                | Rare       |
 | f7      | Toggle line truncation/wrap                     | Rare       |
 | f9 T    | Toggle insert inactive timestamp                | Rare       |
 | C-c a   | Enter Agenda (minimal emacs testing)            | Rare       |

 Here is the keybinding setup in lisp:
 #+header: :tangle yes
 #+begin_src emacs-lisp
   ;; Custom Key Bindings
   (global-set-key (kbd "<f12>") 'org-agenda)  
   (global-set-key (kbd "<f2> h") 'bh/hide-other)
   (global-set-key (kbd "<f2> n") 'bh/toggle-next-task-display)

   (global-set-key (kbd "<f2> o") 'bh/make-org-scratch)
   (global-set-key (kbd "<f2> s") 'bh/switch-to-scratch)

   (global-set-key (kbd "<f2> v") 'visible-mode)
   (global-set-key (kbd "<f2> l") 'org-toggle-link-display)
   (global-set-key (kbd "M-<f2>") 'org-toggle-inline-images)
   (global-set-key (kbd "C-x n r") 'narrow-to-region)
   (global-set-key (kbd "C-<f10>") 'next-buffer)
   (global-set-key (kbd "<f11>") 'org-clock-goto)
   (global-set-key (kbd "<f3>") 'org-clock-in)
   (global-set-key (kbd "<f3>") 'org-clock-out)

   (defun bh/hide-other ()
     (interactive)
     (save-excursion
       (org-back-to-heading 'invisible-ok)
       (hide-other)
       (org-cycle)
       (org-cycle)
       (org-cycle)))

   (defun bh/set-truncate-lines ()
     "Toggle value of truncate-lines and refresh window display."
     (interactive)
     (setq truncate-lines (not truncate-lines))
     ;; now refresh window display (an idiom from simple.el):
     (save-excursion
       (set-window-start (selected-window)
                         (window-start (selected-window)))))

   (defun bh/make-org-scratch ()
     (interactive)
     (find-file "/tmp/publish/scratch.org")
     (gnus-make-directory "/tmp/publish"))

   (defun bh/switch-to-scratch ()
     (interactive)
     (switch-to-buffer "*scratch*"))
 #+end_src

 The main reason I have special key bindings (like =F11=, and =F12=) is
 so that the keys work in any mode.  If I'm in the Gnus summary buffer
 then =C-u C-c C-x C-i= doesn't work, but the =C-F11= key combination
 does and this saves me time since I don't have to visit an org-mode
 buffer first just to clock in a recent task.
** Tasks and States
   :PROPERTIES:
   :CUSTOM_ID: TasksAndStates
   :END:

 I use one set of TODO keywords for all of my org files.  Org-mode lets
 you define TODO keywords per file but I find it's easier to have a
 standard set of TODO keywords globally so I can use the same setup in
 any org file I'm working with.

 The only exception to this is this document :) since I don't want
 =org-mode= hiding the =TODO= keyword when it appears in headlines.
 I've set up a dummy =#+SEQ_TODO: FIXME FIXED= entry at the top of this
 file just to leave my =TODO= keyword untouched in this document.
*** TODO keywords
    :PROPERTIES:
    :CUSTOM_ID: TodoKeywords
    :END:

 I use a light colour theme in emacs.  I find this easier to read on bright sunny days.

 Here are my =TODO= state keywords and colour settings:

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-todo-keywords
       (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
               (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

 (setq org-todo-keyword-faces
       (quote (("TODO" :foreground "red" :weight bold)
               ("NEXT" :foreground "blue" :weight bold)
               ("DONE" :foreground "forest green" :weight bold)
               ("WAITING" :foreground "orange" :weight bold)
               ("HOLD" :foreground "magenta" :weight bold)
               ("CANCELLED" :foreground "forest green" :weight bold)
               ("MEETING" :foreground "forest green" :weight bold)
               ("PHONE" :foreground "forest green" :weight bold))))
 #+end_src
**** Task States
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordTaskStates
     :END:

 Tasks go through the sequence =TODO= -> =DONE=.

 The following diagram shows the possible state transitions for a task.

 #+begin_src plantuml :file normal_task_states.png :cache yes
 title Task States
 [*] -> TODO
 TODO -> NEXT
 TODO -> DONE
 NEXT -> DONE
 DONE -> [*]
 TODO --> WAITING
 WAITING --> TODO
 NEXT --> WAITING
 WAITING --> NEXT
 HOLD --> CANCELLED
 WAITING --> CANCELLED
 CANCELLED --> [*]
 TODO --> HOLD
 HOLD --> TODO
 TODO --> CANCELLED
 TODO: t
 NEXT: n
 DONE: d
 WAITING:w
 note right of WAITING: Note records\nwhat it is waiting for
 HOLD:h
 note right of CANCELLED: Note records\nwhy it was cancelled
 CANCELLED:c
 WAITING --> DONE
 #+end_src

 #+results[61c867b8eb4f49bc47e44ec2b534ac3219d82594]:
 [[file:normal_task_states.png]]

**** Project Task States
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordProjectTaskStates
     :END:

 I use a lazy project definition.  I don't like to bother with manually
 stating 'this is a project' and 'that is not a project'.  For me a project
 definition is really simple.  If a task has subtasks with a todo keyword
 then it's a project.  That's it.

 Projects can be defined at any level - just create a task with a todo
 state keyword that has at least one subtask also with a todo state
 keyword and you have a project.  Projects use the same todo keywords
 as regular tasks.  One subtask of a project needs to be marked =NEXT=
 so the project is not on the stuck projects list.
**** Phone Calls
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordPhoneCalls
     :END:

 Telephone calls are special.  They are created in a done state by a capture task.
 The time of the call is recorded for as long as the capture task is active.  If I need 
 to look up other details and want to close the capture task early I can just 
 =C-c C-c= to close the capture task (stopping the clock) and then =f9 SPC= to resume
 the clock in the phone call while I do other things.
 #+begin_src plantuml :file phone_states.png :cache yes
 title Phone Call Task State
 [*] -> PHONE
 PHONE -> [*]
 #+end_src

 #+results[9e27f3a56c4fca8f05455e6dfa1282030ae52830]:
 [[file:phone_states.png]]

**** Meetings
     :PROPERTIES:
     :CUSTOM_ID: TodoKeywordMeetings
     :END:

 Meetings are special.  They are created in a done state by a capture
 task.  I use the MEETING capture template when someone interrupts what
 I'm doing with a question or discussion.  This is handled similarly to
 phone calls where I clock the amount of time spent with whomever it is
 and record some notes of what was discussed (either during or after
 the meeting) depending on content, length, and complexity of the
 discussion.

 The time of the meeting is recorded for as long as the capture task is
 active.  If I need to look up other details and want to close the
 capture task early I can just =C-c C-c= to close the capture task
 (stopping the clock) and then =f9 SPC= to resume the clock in the
 meeting task while I do other things.
 #+begin_src plantuml :file meeting_states.png :cache yes
 title Meeting Task State
 [*] -> MEETING
 MEETING -> [*]
 #+end_src

 #+results[942fb408787905ffcdde421ee02edabdbb921b06]:
 [[file:meeting_states.png]]

*** Fast Todo Selection
    :PROPERTIES:
    :CUSTOM_ID: FastTodoSelection
    :END:

 Fast todo selection allows changing from any task todo state to any
 other state directly by selecting the appropriate key from the fast
 todo selection key menu.  This is a great feature!

 #+header: :tangle yes
 #+begin_src emacs-lisp 
 (setq org-use-fast-todo-selection t)
 #+end_src

 Changing a task state is done with =C-c C-t KEY=

 where =KEY= is the appropriate fast todo state selection key as defined in =org-todo-keywords=.

 The setting
 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-treat-S-cursor-todo-selection-as-state-change nil)
 #+end_src
 allows changing todo states with S-left and S-right skipping all of
 the normal processing when entering or leaving a todo state.  This
 cycles through the todo states but skips setting timestamps and
 entering notes which is very convenient when all you want to do is fix
 up the status of an entry.
*** TODO state triggers
    :PROPERTIES:
    :CUSTOM_ID: ToDoStateTriggers
    :END:

 I have a few triggers that automatically assign tags to tasks based on
 state changes.  If a task moves to =CANCELLED= state then it gets a
 =CANCELLED= tag.  Moving a =CANCELLED= task back to =TODO= removes the
 =CANCELLED= tag.  These are used for filtering tasks in agenda views
 which I'll talk about later.

 The triggers break down to the following rules:

 - Moving a task to =CANCELLED= adds a =CANCELLED= tag
 - Moving a task to =WAITING= adds a =WAITING= tag
 - Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
 - Moving a task to a done state removes =WAITING= and =HOLD= tags
 - Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
 - Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
 - Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags

 The tags are used to filter tasks in the agenda views conveniently.

 #+header: :tangle yes
 #+begin_src emacs-lisp 
 (setq org-todo-state-tags-triggers
       (quote (("CANCELLED" ("CANCELLED" . t))
               ("WAITING" ("WAITING" . t))
               ("HOLD" ("WAITING") ("HOLD" . t))
               (done ("WAITING") ("HOLD"))
               ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
               ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
               ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
 #+end_src
** Adding New Tasks Quickly with Org Capture
   :PROPERTIES:
   :CUSTOM_ID: Capture
   :END:

 Org Capture mode replaces remember mode for capturing tasks and notes.

 To add new tasks efficiently I use a minimal number of capture
 templates.  I used to have lots of capture templates, one for each
 org-file.  I'd start org-capture with =C-c c= and then pick a template
 that filed the task under =* Tasks= in the appropriate file.

 I found I still needed to refile these capture tasks again to the
 correct location within the org-file so all of these different capture
 templates weren't really helping at all.  Since then I've changed my
 workflow to use a minimal number of capture templates -- I create the
 new task quickly and refile it once.  This also saves me from
 maintaining my org-capture templates when I add a new org file.
*** Capture Templates
    :PROPERTIES:
    :CUSTOM_ID: CaptureTemplates
    :END:

 When a new task needs to be added I categorize it into one of a few
 things:

 - A phone call (p)
 - A meeting (m)
 - An email I need to respond to (r)
 - A new task (t)
 - A new note (n)
 - An interruption (j)
 - A new habit (h)

 and pick the appropriate capture task.

 Here is my setup for org-capture

 #+header: :tangle yes
 #+begin_src emacs-lisp
   (setq org-directory "~/.org/gtd/")
   (setq org-default-notes-file "~/.org/gtd/inbox.org")

   ;; I use C-c c to start capture mode
   (global-set-key (kbd "C-c c") 'org-capture)

   (defvar jethro/org-basic-inbox-template "* TODO %^{Task}
   :PROPERTIES:
   :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
   :END:
   Captured %<%Y-%m-%d %H:%M>
   %a
   %i
   %?")

   ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
   (setq org-capture-templates
         `(("t" "todo" entry (file "~/.org/gtd/inbox.org")
            ,jethro/org-basic-inbox-template)
           ("r" "respond" entry (file "~/.org/gtd/inbox.org")
            "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t) 
           ("w" "org-protocol" entry (file "~/.org/gtd/inbox.org")
            "* TODO Review %c\n%U\n" :immediate-finish t)))
 #+end_src

 Capture mode now handles automatically clocking in and out of a
 capture task.  This all works out of the box now without special hooks.
 When I start a capture mode task the task is clocked in as specified
 by =:clock-in t= and when the task is filed with =C-c C-c= the clock 
 resumes on the original clocking task.

 The quick clocking in and out of capture mode tasks (often it takes
 less than a minute to capture some new task details) can leave
 empty clock drawers in my tasks which aren't really useful.  Since I
 remove clocking lines with 0:00 length I end up with a clock drawer
 like this:

 #+begin_src org :exports src
 ,* TODO New Capture Task
   :LOGBOOK:
   :END:
   [2010-05-08 Sat 13:53]
 #+end_src
 I have the following setup to remove these empty =LOGBOOK= drawers if
 they occur.

*** Separate file for Capture Tasks
    :PROPERTIES:
    :CUSTOM_ID: CaptureRefileOrg
    :END:

 I have a single org file which is the target for my capture templates.

 I store notes, tasks, phone calls, and org-protocol tasks in
 =refile.org=.  I used to use multiple files but found that didn't
 really have any advantage over a single file.

 Normally this file is empty except for a single line at the top which
 creates a =REFILE= tag for anything in the file.

 The file has a single permanent line at the top like this
 #+begin_src org :exports src
 ,#+FILETAGS: REFILE
 #+end_src
*** Capture Tasks is all about being FAST
    :PROPERTIES:
    :CUSTOM_ID: CaptureTasksAreFast
    :END:

 Okay I'm in the middle of something and oh yeah - I have to remember
 to do that.  I don't stop what I'm doing.  I'm probably clocking a
 project I'm working on and I don't want to lose my focus on that but I
 can't afford to forget this little thing that just came up.

 So what do I do?  Hit =C-c c= to start capture mode and select =t=
 since it's a new task and I get a buffer like this:

 #+begin_src org :exports src
 ,* TODO 
   [2010-08-05 Thu 21:06]

   [[file:~/git/org-mode-doc/org-mode.org::*Capture%20Tasks%20is%20all%20about%20being%20FAST][Capture Tasks is all about being FAST]]
 #+end_src

 Enter the details of the TODO item and =C-c C-c= to file it away in
 refile.org and go right back to what I'm really working on secure in
 the knowledge that that item isn't going to get lost and I don't have
 to think about it anymore at all now.

 The amount of time I spend entering the captured note is clocked.  The
 capture templates are set to automatically clock in and out of the
 capture task.  This is great for interruptions and telephone calls
 too.
** Refiling Tasks
   :PROPERTIES:
   :CUSTOM_ID: Refiling
   :END:

 Refiling tasks is easy.  After collecting a bunch of new tasks in my
 refile.org file using capture mode I need to move these to the
 correct org file and topic.  All of my active org-files are in my
 =org-agenda-files= variable and contribute to the agenda.

 I collect capture tasks in refile.org for up to a week.  These now
 stand out daily on my block agenda and I usually refile them during
 the day.  I like to keep my refile task list empty.
*** Refile Setup
    :PROPERTIES:
    :CUSTOM_ID: RefileSetup
    :END:

 To refile tasks in org you need to tell it where you want to refile things.

 In my setup I let any file in =org-agenda-files= and the current file
 contribute to the list of valid refile targets.  

 I've recently moved to using IDO to complete targets directly.  I find
 this to be faster than my previous complete in steps setup.  At first
 I didn't like IDO but after reviewing the documentation again and
 learning about =C-SPC= to limit target searches I find it is much
 better than my previous complete-in-steps setup.  Now when I want to
 refile something I do =C-c C-w= to start the refile process, then type
 something to get some matching targets, then =C-SPC= to restrict the
 matches to the current list, then continue searching with some other
 text to find the target I need.  =C-j= also selects the current
 completion as the final target.  I like this a lot.  I show full
 outline paths in the targets so I can have the same heading in
 multiple subtrees or projects and still tell them apart while
 refiling.

 I now exclude =DONE= state tasks as valid refile targets.  This helps to keep the
 refile target list to a reasonable size.

 Here is my refile configuration:
 #+header: :tangle yes
 #+begin_src emacs-lisp
 ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
 (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                  (org-agenda-files :maxlevel . 9))))

 ; Use full outline paths for refile targets - we file directly with IDO
 (setq org-refile-use-outline-path t)

 ; Targets complete directly with IDO
 (setq org-outline-path-complete-in-steps nil)

 ; Allow refile to create parent tasks with confirmation
 (setq org-refile-allow-creating-parent-nodes (quote confirm))

 (setq org-completion-use-ido t)
 
 ;;;; Refile settings
 ; Exclude DONE state tasks from refile targets
 (defun bh/verify-refile-target ()
   "Exclude todo keywords with a done state from refile targets"
   (not (member (nth 2 (org-heading-components)) org-done-keywords)))

 (setq org-refile-target-verify-function 'bh/verify-refile-target)
 #+end_src

 To refile a task to my =norang.org= file under =System Maintenance= I
 just put the cursor on the task and hit =C-c C-w= and enter =nor C-SPC
 sys RET= and it's done.  IDO completion makes locating targets a snap.
*** Refiling Tasks
    :PROPERTIES:
    :CUSTOM_ID: RefilingTasks
    :END:

 Tasks to refile are in their own section of the block agenda.  To find
 tasks to refile I run my agenda view with =F12 SPC= and scroll down to
 second section of the block agenda: =Tasks to Refile=.  This view
 shows all tasks (even ones marked in a =done= state).

 Bulk refiling in the agenda works very well for multiple tasks going
 to the same place.  Just mark the tasks with =m= and then =B r= to
 refile all of them to a new location.  Occasionally I'll also refile
 tasks as subtasks of the current clocking task using =C-2 C-c C-w=
 from the =refile.org= file.

 Refiling all of my tasks tends to take less than a minute so I
 normally do this a couple of times a day.
** Custom agenda views
   :PROPERTIES:
   :CUSTOM_ID: CustomAgendaViews
   :END:

 I now have one block agenda view that has everything on it.  I also
 keep separate single view agenda commands for use on my slower Eee
 PC - since it takes prohibitively long to generate my block agenda on
 that slow machine.  I'm striving to simplify my layout with everything
 at my fingertips in a single agenda on my workstation which is where I
 spend the bulk of my time.

 Most of my old custom agenda views were rendered obsolete when
 filtering functionality was added to the agenda in newer versions of
 =org-mode= and now with block agenda functionality I can combine
 everything into a single view.

 Custom agenda views are used for:
 - Single block agenda shows the following
   - overview of today
   - Finding tasks to be refiled
   - Finding stuck projects
   - Finding NEXT tasks to work on
   - Show all related tasks
   - Reviewing projects
   - Finding tasks waiting on something
   - Findings tasks to be archived
 - Finding notes
 - Viewing habits

 If I want just today's calendar view then =F12 a= is still faster than
 generating the block agenda - especially if I want to view a week or
 month's worth of information, or check my clocking data.  In that case
 the extra detail on the block agenda view is never really needed and I
 don't want to spend time waiting for it to be generated.
*** Setup
    :PROPERTIES:
    :CUSTOM_ID: CustomAgendaViewSetup
    :END:

 #+header: :tangle yes
 #+begin_src emacs-lisp
   ;; Do not dim blocked tasks
   (setq org-agenda-dim-blocked-tasks nil)

   ;; Compact the block agenda view
   (setq org-agenda-compact-blocks t)

   ;; Custom agenda command definitions
   (setq org-agenda-custom-commands
         '((" " "Agenda"
            ((agenda "" nil)
             (tags "REFILE"
                   ((org-agenda-overriding-header "Tasks to Refile")
                    (org-tags-match-list-sublevels nil)))
             (tags-todo "-CANCELLED/!"
                        ((org-agenda-overriding-header "Stuck Projects")
                         (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-HOLD-CANCELLED/!"
                        ((org-agenda-overriding-header "Projects")
                         (org-agenda-skip-function 'bh/skip-non-projects)
                         (org-tags-match-list-sublevels 'indented)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-CANCELLED/!NEXT"
                        ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                         (org-tags-match-list-sublevels t)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(todo-state-down effort-up category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Project Subtasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-CANCELLED+WAITING|HOLD/!"
                        ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-tasks)
                         (org-tags-match-list-sublevels nil)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks))) 
             (tags "-REFILE/"
                   ((org-agenda-overriding-header "Tasks to Archive")
                    (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                    (org-tags-match-list-sublevels nil))))
            nil)))

 #+end_src

 My block agenda view looks like this when not narrowed to a project.
 This shows top-level projects and =NEXT= tasks but hides the project details since
 we are not focused on any particular project.

 *NOTE:* This agenda screen shot is out of date and does not currently match the agenda setup in this document.
 This will be fixed soon.

 [[file:block-agenda-nonproject.png]]

 After selecting a project (with =P= on any task in the agenda) the block agenda changes to show the project and
 any subprojects in the Projects section.  Tasks show project-related tasks that are hidden when not
 narrowed to a project.

 This makes it easy to focus on the task at hand.

 *NOTE:* This agenda screen shot is out of date and does not currently match the agenda setup in this document.
 This will be fixed soon.


 [[file:block-agenda-project.png]]

 I generally work top-down on the agenda.  Things with deadlines and
 scheduled dates (planned to work on today or earlier) show up in the
 agenda at the top.

 My day goes generally like this:

 - Punch in (this starts the clock on the default task)
 - Look at the agenda and make a mental note of anything important to deal with today
 - Read email and news
   - create notes, and tasks for things that need responses with org-capture
 - Check refile tasks and respond to emails
 - Look at my agenda and work on important tasks for today
   - Clock it in
   - Work on it until it is =DONE= or it gets interrupted
 - Work on tasks
 - Make journal entries (=C-c c j=) for interruptions
 - Punch out for lunch and punch back in after lunch
 - work on more tasks
 - Refile tasks to empty the list
   - Tag tasks to be refiled with =m= collecting all tasks for the same target
   - Bulk refile the tasks to the target location with =B r=
   - Repeat (or refile individually with =C-c C-w=) until all refile tasks are gone
 - Mark habits done today as DONE
 - Punch out at the end of the work day
*** What do I work on next?
    :PROPERTIES:
    :CUSTOM_ID: WhatDoIWorkOnNext
    :END:

 Start with deadlines and tasks scheduled today or earlier from the
 daily agenda view.  Then move on to tasks in the =Next Tasks= list in
 the block agenda view.  I tend to schedule current projects to 'today'
 when I start work on them and they sit on my daily agenda reminding me
 that they need to be completed.  I normally only schedule one or two
 projects to the daily agenda and unschedule things that are no longer
 important and don't deserve my attention today.

 When I look for a new task to work on I generally hit =F12 SPC= to get
 the block agenda and follow this order:

 - Pick something off today's agenda
   - deadline for today (do this first - it's not late yet)
   - deadline in the past (it's already late)
   - a scheduled task for today (it's supposed to be done today)
   - a scheduled task that is still on the agenda
   - deadline that is coming up soon
 - pick a NEXT task
 - If you run out of items to work on look for a NEXT task in the current context
   pick a task from the Tasks list of the current project.
**** Why keep it all on the =NEXT= list?
     :PROPERTIES:
     :CUSTOM_ID: CustomAgendaViewsNextList
     :END:

 I've moved to a more GTD way of doing things.  Now I just use a =NEXT=
 list.  Only projects get tasks with =NEXT= keywords since stuck projects
 initiate the need for marking or creating =NEXT= tasks.  A =NEXT= task
 is something that is available to work on /now/, it is the next
 logical step in some project.

 I used to have a special keyword =ONGOING= for things that I do a lot
 and want to clock but never really start/end.  I had a special agenda
 view for =ONGOING= tasks that I would pull up to easily find the thing
 I want to clock.

 Since then I've moved away from using the =ONGOING= todo keyword.
 Having an agenda view that shows =NEXT= tasks makes it easy to pick
 the thing to clock - and I don't have to remember if I need to look in
 the =ONGOING= list or the =NEXT= list when looking for the task to
 clock-in.  The =NEXT= list is basically 'what is current' - any task
 that moves a project forward.  I want to find the thing to work on as
 fast as I can and actually do work on it - not spend time hunting
 through my org files for the task that needs to be clocked-in.

 To drop a task off the =NEXT= list simply move it back to the =TODO=
 state.
*** Reading email, newsgroups, and conversations on IRC
    :PROPERTIES:
    :CUSTOM_ID: ReadingMailNewsIRC
    :END:

 When reading email, newsgroups, and conversations on IRC I just let
 the default task (normally =** Organization=) clock the time I spend on
 these tasks.  To read email I go to Gnus and read everything in my
 inboxes.  If there are emails that require a response I use
 org-capture to create a new task with a heading of 'Respond to <user>'
 for each one.  This automatically links to the email in the task and
 makes it easy to find later.  Some emails are quick to respond to and
 some take research and a significant amount of time to complete.  I
 clock each one in it's own task just in case I need that clocked time
 later.  The capture template for Repond To tasks is now scheduled for
 today so I can refile the task to the appropriate org file without
 losing the task for a week.

 Next, I go to my newly created tasks to be refiled from the block
 agenda with =F12 a= and clock in an email task and deal with it.
 Repeat this until all of the 'Respond to <user>' tasks are marked
 =DONE=.

 I read email and newgroups in Gnus so I don't separate clocked time
 for quickly looking at things.  If an article has a useful piece of
 information I want to remember I create a note for it with =C-c c n=
 and enter the topic and file it.  This takes practically no time at
 all and I know the note is safely filed for later retrieval.  The time
 I spend in the capture buffer is clocked with that capture note.
*** Filtering
    :PROPERTIES:
    :CUSTOM_ID: CustomAgendaViewFiltering
    :END:

 So many tasks, so little time.  I have hundreds of tasks at any given
 time (373 right now).  There is so much stuff to look at it can be
 daunting.  This is where agenda filtering saves the day.

 It's 11:53AM and I'm in work mode just before lunch.  I don't want to
 see tasks that are not work related right now.  I also don't want to
 work on a big project just before lunch... so I need to find small
 tasks that I can knock off the list.

 How do we do this?  Get a list of NEXT tasks from the block agenda and
 then narrow it down with filtering.  Tasks are ordered in the NEXT
 agenda view by estimated effort so the short tasks are first -- just
 start at the top and work your way down.  I can limit the displayed
 agenda tasks to those estimates of 10 minutes or less with =/ + 1= and
 I can pick something that fits the minutes I have left before I take
 off for lunch.
**** Automatically removing context based tasks with / RET
     :PROPERTIES:
     :CUSTOM_ID: CustomAgendaViewFilteringContext
     :END:

 =/ RET= in the agenda is really useful.  This awesome feature was
 added to org-mode by John Wiegley.  It removes tasks automatically by
 filtering based on a user-provided function.

 At work I have projects I'm working on which are assigned by my
 manager.  Sometimes priorities changes and projects are delayed to
 sometime in the future.  This means I need to stop working on these
 immediately.  I put the project task on =HOLD= and work on something
 else.  The =/ RET= filter removes =HOLD= tasks and subtasks (because
 of tag inheritance).

 At home I have some tasks tagged with =farm= since these need to be
 performed when I am physically at our family farm.  Since I am there
 infrequently I have added =farm= to the list of auto-excluded tags on
 my system.  I can always explicitly filter to just =farm= tasks with
 =/ TAB farm RET= when I am physically there.

 I have the following setup to allow =/ RET= to filter tasks based on
 the description above.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (defun bh/org-auto-exclude-function (tag)
   "Automatic task exclusion in the agenda with / RET"
   (and (cond
         ((string= tag "hold")
          t)
         ((string= tag "farm")
          t))
        (concat "-" tag)))

 (setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
 #+end_src

 This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not
 supposed to be working on now from the list of returned results.

 This helps to keep my agenda clutter-free.
** Tags
   :PROPERTIES:
   :CUSTOM_ID: Tags
   :END:

 Tasks can have any number of arbitrary tags.  Tags are used for:

 - filtering todo lists and agenda views
 - providing context for tasks
 - tagging notes
 - tagging phone calls
 - tagging meetings
 - tagging tasks to be refiled
 - tagging tasks in a WAITING state because a parent task is WAITING
 - tagging cancelled tasks because a parent task is CANCELLED
 - preventing export of some subtrees when publishing

 I use tags mostly for filtering in the agenda.  This means you can
 find tasks with a specific tag easily across your large number of
 org-mode files.

 Some tags are mutually exclusive.  These are defined in a group so
 that only one of the tags can be applied to a task at a time
 (disregarding tag inheritance).  I use these types for tags for
 applying context to a task.  (Work tasks have an =@office= tag, and
 are done at the office, Farm tasks have an =@farm= tag and are done at
 the farm -- I can't change the oil on the tractor if I'm not at the
 farm... so I hide these and other tasks by filtering my agenda view to
 only =@office= tasks when I'm at the office.)

 Tasks are grouped together in org-files and a =#+FILETAGS:= entry
 applies a tag to all tasks in the file.  I use this to apply a tag to
 all tasks in the file.  My norang.org file creates a NORANG file tag
 so I can filter tasks in the agenda in the norang.org file easily.
*** Tags
    :PROPERTIES:
    :CUSTOM_ID: OrgTagAlist
    :END:

 Here are my tag definitions with associated keys for filtering in the
 agenda views.

 The startgroup - endgroup (=@XXX=) tags are mutually exclusive -
 selecting one removes a similar tag already on the task.  These are
 the context tags - you can't be in two places at once so if a task is
 marked with @farm and you add @office then the @farm tag is removed
 automagically.

 The other tags =WAITING= .. =FLAGGED= are not mutually exclusive and
 multiple tags can appear on a single task.  Some of those tags are
 created by todo state change triggers.  The shortcut key is used to
 add or remove the tag using =C-c C-q= or to apply the task for
 filtering on the agenda.

 I have both =FARM= and =@farm= tags.  =FARM= is set by a =FILETAGS=
 entry and just gives me a way to filter anything farm related.  The
 =@farm= tag signifies that the task as to be done /at the farm/.  If I
 have to call someone about something that would have a =FARM= tag but
 I can do that at home on my lunch break.  I don't physically have to
 be at the farm to make the call.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 ; Tags with fast selection keys
 (setq org-tag-alist (quote ((:startgroup)
                             ("@errand" . ?e)
                             ("@office" . ?o)
                             ("@home" . ?H)
                             ("@farm" . ?f)
                             (:endgroup)
                             ("WAITING" . ?w)
                             ("HOLD" . ?h)
                             ("PERSONAL" . ?P)
                             ("WORK" . ?W)
                             ("FARM" . ?F)
                             ("ORG" . ?O)
                             ("NORANG" . ?N)
                             ("crypt" . ?E)
                             ("NOTE" . ?n)
                             ("CANCELLED" . ?c)
                             ("FLAGGED" . ??))))

 ; Allow setting single tags without the menu
 (setq org-fast-tag-selection-single-key (quote expert))

 ; For tag searches ignore tasks with scheduled and deadline dates
 (setq org-agenda-tags-todo-honor-ignore-options t)
 #+end_src
*** Filetags
    :PROPERTIES:
    :CUSTOM_ID: FileTags
    :END:

 Filetags are a convenient way to apply one or more tags to all of the
 headings in a file.

 Filetags look like this:

 #+begin_src org :exports src
 ,#+FILETAGS: NORANG @office
 #+end_src

 I have the following =#+FILETAGS:= entries in my org-mode files:
**** Non-work related org-mode files
     :PROPERTIES:
     :CUSTOM_ID: TaggingNonWorkFiles
     :END:

 | File         | Tags                  |
 |--------------+-----------------------|
 | todo.org     | PERSONAL              |
 | gsoc2009.org | GSOC PERSONAL         |
 | git.org      | GIT WORK              |
 | org.org      | ORG WORK              |
 | mark.org     | MARK PERSONAL         |
 | farm.org     | FARM PERSONAL         |
**** Work related org-mode files
     :PROPERTIES:
     :CUSTOM_ID: TaggingWorkFiles
     :END:

 | File        | Tags            |
 |-------------+-----------------|
 | norang.org  | NORANG @office  |
 | ABC.org     | ABC @office     |
 | XYZ.org     | XYZ @office     |
 | ABC-DEF.org | ABC DEF @office |
 | ABC-KKK.org | ABC KKK @office |
 | YYY.org     | YYY @office     |
**** Refile tasks
     :PROPERTIES:
     :CUSTOM_ID: RefileTasks
     :END:

 | File       | Tags         |
 |------------+--------------|
 | refile.org | REFILE       |
 |------------+--------------|
*** State Trigger Tags
    :PROPERTIES:
    :CUSTOM_ID: StateTriggerTags
    :END:

 The following tags are automatically added or removed by todo state
 triggers described previously in [[#ToDoStateTriggers][ToDo state triggers]]

 - =WAITING=
   - =CANCELLED=
** GTD stuff
   :PROPERTIES:
   :CUSTOM_ID: GTD
   :
 Most of my day is deadline/schedule driven.
 I work off of the agenda first and then pick items from the todo lists as
 outlined in [[#WhatDoIWorkOnNext][What do I work on next?]]
*** Weekly Review Process
    :PROPERTIES:
    :CUSTOM_ID: GTDWeeklyReview
    :END:

 The first day of the week (usually Monday) I do my weekly review. 
 I keep a list like this one to remind me what needs to be done.

 To keep the agenda fast I set
 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-agenda-span 'day)
 #+end_src
 so only today's date is shown by default.  I only need the weekly
 view during my weekly review and this keeps my agenda generation
 fast.

 I have a recurring task which keeps my weekly review checklist
 handy.  This pops up as a reminder on Monday's.  This week I'm
 doing my weekly review on Tuesday since Monday was a holiday.

 #+begin_src org :exports src
 ,* NEXT Weekly Review [0/6]
   SCHEDULED: <2009-05-18 Mon ++1w> 
   :LOGBOOK:...
   :PROPERTIES:...

   What to review:

    - [ ] Check follow-up folder
    - [ ] Review weekly agenda =F12 a w //=
    - [ ] Check clocking data for past week =v c=
    - [ ] Review clock report for past week =R=
      - Check where we spent time (too much or too little) and rectify this week
    - [ ] Look at entire agenda for today  =F12 SPC=
    - [ ] Review projects =F12 SPC //= and =V= repeatedly to view each project

    - start work
      - daily agenda first - knock off items
      - then work on NEXT tasks
 #+end_src
 The first item [ ] Check follow-up folder makes me pull out the paper
 file I dump stuff into all week long - things I need to take care of
 but are in no particular hurry to deal with.  Stuff I get in the mail
 etc. that I don't want to deal with now.  I just toss it in my
 =Follow-Up= folder in the filing cabinet and forget about it until the
 weekly review.

 I go through the folder and weed out anything that needs to be dealt
 with.  After that everything else is in =org-mode=.  I tend to
 schedule tasks onto the agenda for the coming week so that I don't
 spend lots of time trying to find what needs to be worked on next.

 This works for me.  Your mileage may vary ;)
*** Project definition and finding stuck projects
    :PROPERTIES:
    :CUSTOM_ID: Projects
    :END:

 I'm using a new lazy project definition to mark tasks as projects.
 This requires zero effort from me.  Any task with a subtask using a
 todo keyword is a project.  Period.

 Projects are 'stuck' if they have no subtask with a =NEXT= todo
 keyword task defined.

 The org-mode stuck projects agenda view lists projects that have no
 =NEXT= task defined.  Stuck projects show up on my block agenda and I
 tend to assign a =NEXT= task so the list remains empty.  This helps to
 keep projects moving forward.

 I disable the default org-mode stuck projects agenda view with the
 following setting.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-stuck-projects (quote ("" nil nil "")))
 #+end_src

 This prevents org-mode from trying to show incorrect data if I select
 the default stuck project view with =F12 #= from the agenda menu.  My
 customized stuck projects view is part of my block agenda displayed
 with =F12 SPC=.

 Projects can have subprojects - and these subprojects can also be stuck.
 Any project that is stuck shows up on the stuck projects list so I can
 indicate or create a =NEXT= task to move that project forward.

 In the following example =Stuck Project A= is stuck because it has no
 subtask which is =NEXT=.  =Project C= is not stuck because it has
 =NEXT= tasks =SubTask G= and =Task I=.  =Stuck Sub Project D= is stuck
 because =SubTask E= is not =NEXT= and there are no other tasks
 available in this project.

 #+begin_src org :exports src
 ,* Category
 ,** TODO Stuck Project A
 ,*** TODO Task B
 ,** TODO Project C
 ,*** TODO Stuck Sub Project D
 ,**** TODO SubTask E
 ,*** TODO Sub Project F
 ,**** NEXT SubTask G
 ,**** TODO SubTask H
 ,*** NEXT Task I
 ,*** TODO Task J
 #+end_src

 All of the stuck projects and subprojects show up in the stuck
 projects list and that is my indication to assign or create =NEXT=
 tasks until the stuck projects list is empty.  Occasionally some
 subtask is =WAITING= for something and the project is stuck until that
 condition is satisfied.  In this case I leave it on the stuck project
 list and just work on something else.  This stuck project 'bugs' me
 regularly when I see it on the block agenda and this prompts me to
 follow up on the thing that I'm waiting for.

 I have the following helper functions defined for projects which are
 used by agenda views.
 #+header: :tangle yes
 #+begin_src emacs-lisp
   (defun bh/is-project-p ()
     "Any task with a todo keyword subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task has-subtask))))

   (defun bh/is-project-subtree-p ()
     "Any task with a todo keyword that is in a project subtree.
   Callers of this function already widen the buffer view."
     (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                 (point))))
       (save-excursion
         (bh/find-project-task)
         (if (equal (point) task)
             nil
           t))))

   (defun bh/is-task-p ()
     "Any task with a todo keyword and no subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task (not has-subtask)))))

   (defun bh/is-subproject-p ()
     "Any task which is a subtask of another project"
     (let ((is-subproject)
           (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
       (save-excursion
         (while (and (not is-subproject) (org-up-heading-safe))
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq is-subproject t))))
       (and is-a-task is-subproject)))

   (defun bh/list-sublevels-for-projects-indented ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
     This is normally used by skipping functions where this variable is already local to the agenda."
     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels 'indented)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defun bh/list-sublevels-for-projects ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
     This is normally used by skipping functions where this variable is already local to the agenda."
     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels t)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defvar bh/hide-scheduled-and-waiting-next-tasks t)

   (defun bh/toggle-next-task-display ()
     (interactive)
     (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
     (when  (equal major-mode 'org-agenda-mode)
       (org-agenda-redo))
     (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

   (defun bh/skip-stuck-projects ()
     "Skip trees that are not stuck projects"
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (if (bh/is-project-p)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                   (unless (member "WAITING" (org-get-tags-at))
                     (setq has-next t))))
               (if has-next
                   nil
                 next-headline)) ; a stuck project, has subtasks but no next task
           nil))))

   (defun bh/skip-non-stuck-projects ()
     "Skip trees that are not stuck projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (if (bh/is-project-p)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                   (unless (member "WAITING" (org-get-tags-at))
                     (setq has-next t))))
               (if has-next
                   next-headline
                 nil)) ; a stuck project, has subtasks but no next task
           next-headline))))

   (defun bh/skip-non-projects ()
     "Skip trees that are not projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (if (save-excursion (bh/skip-non-stuck-projects))
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((bh/is-project-p)
               nil)
              ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
               nil)
              (t
               subtree-end))))
       (save-excursion (org-end-of-subtree t))))

   (defun bh/skip-non-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, and project related tasks."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-task-p)
           nil)
          (t
           next-headline)))))

   (defun bh/skip-project-trees-and-habits ()
     "Skip trees that are projects"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          (t
           nil)))))

   (defun bh/skip-projects-and-habits-and-single-tasks ()
     "Skip trees that are projects, tasks that are habits, single non-project tasks"
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond 
          ((and bh/hide-scheduled-and-waiting-next-tasks
                (member "WAITING" (org-get-tags-at)))
           next-headline)
          ((bh/is-project-p)
           next-headline)
          ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
           next-headline)
          (t
           nil)))))

   (defun bh/skip-project-tasks-maybe ()
     "Show tasks related to the current restriction.
   When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
   When not restricted, skip project and sub-project tasks, habits, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max))))
              (limit-to-project (marker-buffer org-agenda-restrict-begin)))
         (cond
          ((bh/is-project-p)
           next-headline) 
          ((and (not limit-to-project)
                (bh/is-project-subtree-p))
           subtree-end)
          ((and limit-to-project
                (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-project-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          ((bh/is-project-subtree-p)
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-non-project-tasks ()
     "Show project tasks.
   Skip project and sub-project tasks, habits, and loose non-project tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-project-p)
           next-headline) 
          ((and (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          ((not (bh/is-project-subtree-p))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-projects-and-habits ()
     "Skip trees that are projects and tasks that are habits"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end) 
          (t
           nil)))))

   (defun bh/skip-non-subprojects ()
     "Skip trees that are not projects"
     (let ((next-headline (save-excursion (outline-next-heading))))
       (if (bh/is-subproject-p)
           nil
         next-headline)))

   (defun bh/find-project-task ()
     "Move point to the parent (project) task if any"
     (save-restriction
       (widen)
       (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
         (while (org-up-heading-safe)
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq parent-task (point))))
         (goto-char parent-task)
         parent-task)))
 #+end_src
*** Effort Estimates
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-global-properties (quote (("Effort_ALL" . "0 0:10 0:20 0:30 1:00 1:30 2:00 3:00 4:00 6:00 8:00 10:00 20:00"))))
#+END_SRC
** Archiving
   :PROPERTIES:
   :CUSTOM_ID: Archiving
   :END:
*** Archiving Subtrees
    :PROPERTIES:
    :CUSTOM_ID: ArchivingSubtrees
    :END:

 My archiving procedure has changed.  I used to move entire subtrees to
 a separate archive file for the project.  Task subtrees in =FILE.org=
 get archived to =FILE.org_archive= using the =a y= command in the
 agenda.

 I still archive to the same archive file as before but now I archive
 any done state todo task that is old enough to archive.  Tasks to
 archive are listed automatically at the end of my block agenda and
 these are guaranteed to be old enough that I've already billed any
 time associated with these tasks.  This cleans up my project trees and
 removes the old tasks that are no longer interesting.  The archived
 tasks get extra property data created during the archive procedure so
 that it is possible to reconstruct exactly where the archived entry
 came from in the rare case where you want to unarchive something.

 My archive files are huge but so far I haven't found a need to split
 them by year (or decade) :)

 Archivable tasks show up in the last section of my block agenda when a
 new month starts.  Any tasks that are done but have no timestamps this
 month or last month (ie. they are over 30 days old) are available to
 archive.  Timestamps include closed dates, notes, clock data, etc - any
 active or inactive timestamp in the task.

 Archiving is trivial.  Just mark all of the entries in the block agenda
 using the =m= key and then archive them all to the appropriate place
 with =B $=.  This normally takes less than 5 minutes once a month.
*** Archive Setup
    :PROPERTIES:
    :CUSTOM_ID: ArchiveSetup
    :END:

 I no longer use an =ARCHIVE= property in my subtrees.  Tasks can just
 archive normally to the =Archived Tasks= heading in the archive file.

 The following setting ensures that task states are untouched when they
 are archived.  This makes it possible to archive tasks that are not
 marked =DONE=.  By default tasks are archived under the heading =*
 Archived Tasks= in the archive file.

 This archiving function does not keep your project trees intact.  It
 archives done state tasks after they are old enough to they are
 removed from the main org file.  It should be possible to reconstruct
 the original tree from the archive detail properties but I've never
 needed to do this yet.  The archived detail is very useful the few
 times a year I actually need to look for some archived data but most
 of the time I just move it out of the way and keep it for historical
 purposes.

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (setq org-archive-mark-done nil)
 (setq org-archive-location "%s_archive::* Archived Tasks")
 #+end_src

 #+header: :tangle yes
 #+begin_src emacs-lisp
 (defun bh/skip-non-archivable-tasks ()
   "Skip trees that are not available for archiving"
   (save-restriction
     (widen)
     ;; Consider only tasks with done todo headings as archivable candidates
     (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (subtree-end (save-excursion (org-end-of-subtree t))))
       (if (member (org-get-todo-state) org-todo-keywords-1)
           (if (member (org-get-todo-state) org-done-keywords)
               (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                      (a-month-ago (* 60 60 24 (+ daynr 1)))
                      (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                      (this-month (format-time-string "%Y-%m-" (current-time)))
                      (subtree-is-current (save-excursion
                                            (forward-line 1)
                                            (and (< (point) subtree-end)
                                                 (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                 (if subtree-is-current
                     subtree-end ; Has a date in this month or last month, skip it
                   nil))  ; available to archive
             (or subtree-end (point-max)))
         next-headline))))
 #+end_src
*** Archive Tag - Hiding Information
    :PROPERTIES:
    :CUSTOM_ID: ArchiveTagHidesInfo
    :END:

 The only time I set the ARCHIVE tag on a task is to prevent it from
 opening by default because it has tons of information I don't really
 need to look at on a regular basis.  I can open the task with C-TAB if
 I need to see the gory details (like a huge table of data related to
 the task) but normally I don't need that information displayed.
*** When to Archive
    :PROPERTIES:
    :CUSTOM_ID: WhenToArchive
    :END:

 Archiving monthly works well for me.  I keep completed tasks around
 for at least 30 days before archiving them.  This keeps current
 clocking information for the last 30 days out of the archives.  This
 keeps my files that contribute to the agenda fairly current (this
 month, and last month, and anything that is unfinished).  I only
 rarely visit tasks in the archive when I need to pull up ancient
 history for something.

 Archiving keeps my main working files clutter-free.  If I ever need
 the detail for the archived tasks they are available in the
 appropriate archive file.
** Reminders
   :PROPERTIES:
   :CUSTOM_ID: Reminders
   :END:

 I use appt for reminders.  It's simple and unobtrusive -- putting
 pending appointments in the status bar and beeping as 12, 9, 6, 3,
 and 0 minutes before the appointment is due.

 Everytime the agenda is displayed (and that's lots for me) the
 appointment list is erased and rebuilt from the current agenda
 details for today.  This means everytime I reschedule something, add
 or remove tasks that are time related the appointment list is
 automatically updated the next time I look at the agenda.
*** Reminder Setup
    :PROPERTIES:
    :CUSTOM_ID: ReminderSetup
    :END:

 #+header: :tangle yes
 #+begin_src emacs-lisp
 ; Erase all reminders and rebuilt reminders for today from the agenda
 (defun bh/org-agenda-to-appt ()
   (interactive)
   (setq appt-time-msg-list nil)
   (org-agenda-to-appt))

 ; Rebuild the reminders everytime the agenda is displayed
 (add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

 ; This is at the end of my .emacs - so appointments are set up when Emacs starts
 (bh/org-agenda-to-appt)

 ; Activate appointments so we get notifications
 (appt-activate t)

 ; If we leave Emacs running overnight - reset the appointments one minute after midnight
 (run-at-time "24:01" nil 'bh/org-agenda-to-appt)
 #+end_src
** Htmlize
We need =htmlize= to add syntax highlighting to org-exports for HTML files.

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :config
    (require 'htmlize))
#+end_src
** Email integration with org-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-notmuch)
#+END_SRC
** org-publish
#+begin_src emacs-lisp :tangle yes
  (defun jethro/auto-git-commit-and-push (dir)
    (shell-command (format "cd %s && git add -A && git commit -m \"%s\" && git push origin master" dir "New changes: $(date)")))

  (setq jethro/emacsd-site-dir "~/Documents/Code/emacsd_site/")
  (setq jethro/books-dir "~/Documents/Code/books/")

  (setq org-publish-project-alist
        '(("books"
           ;; Path to your org files.
           :publishing-function org-html-publish-to-html
           :publishing-directory jethro/books-dir
           :base-directory "~/.org/"
           :completion-function (lambda () 
                                  (shell-command (format "cd %s && ruby books.rb && git add -A && git commit -m \"%s\" && git push origin master" jethro/books-dir "New changes: $(date)")))
           :exclude ".*"
           :include ["books.org"]
           :with-emphasize t
           :with-todo-keywords t
           :with-toc nil
           :html-preamble t)
          ("emacs.d"
           :publishing-function org-html-publish-to-html
           :publishing-directory jethro/emacsd-site-dir
           :base-directory "~/.emacs.d/"
           :exclude ".*"
           :include ["init.org"]
           :completion-function (lambda () (let ((htmlfile (concat jethro/emacsd-site-dir
                                                                   "init.html")))
                                             (if (file-exists-p htmlfile)
                                                 (progn
                                                   (rename-file htmlfile
                                                                (concat jethro/emacsd-site-dir
                                                                        "index.html") t)
                                                   (jethro/auto-git-commit-and-push jethro/emacsd-site-dir)))))
           :with-emphasize t
           :with-title nil
           :with-toc t
           :html-head "<link rel=\"stylesheet\" href=\"/css/emacsd.css\" type=\"text/css\">"
           :html-preamble t)))
#+end_src
** org-reveal
#+begin_src emacs-lisp :tangle yes
  (use-package ox-reveal
    :config
    (require 'ox-reveal))
#+end_src
** org-latex
I use export to LaTeX through ox-latex, using xelatex for a nicer export template.
#+begin_src emacs-lisp :tangle yes
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode %f"
          "pdflatex -shell-escape -interaction nonstopmode %f"))
  (require 'ox-latex)
  (setq org-latex-tables-booktabs t)
  (setq org-latex-listings 'minted)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (setq org-latex-minted-options
        '(("frame" "lines")
          ("linenos")
          ("numbersep" "5pt")
          ("framesep" "2mm")
          ("fontfamily" "tt")))
  (add-to-list 'org-latex-classes
               '("book"
                 "\\documentclass[10pt]{memoir}
                        \\usepackage{charter}
                        \\usepackage[T1]{fontenc}
                        \\usepackage{booktabs}
                        \\usepackage{amsmath}
                        \\usepackage{minted}
                        \\usemintedstyle{borland}
                        \\usepackage{color}
                        \\usepackage{epigraph}
                        \\usepackage{enumitem}
                        \\setlist{nosep}
                        \\setlength\\epigraphwidth{13cm}
                        \\setlength\\epigraphrule{0pt}
                        \\usepackage{fontspec}
                        \\usepackage{graphicx}
                        \\usepackage{hyperref}
                        \\hypersetup {colorlinks = true, allcolors = red}
                        \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("books"
                 "\\documentclass[oneside]{tufte-book}
                        \\usepackage{charter}
                        \\usepackage{booktabs}
                        \\usepackage{minted}
                        \\usemintedstyle{bw}
                        \\usepackage{graphicx}

                        \\usepackage{hyperref}
                        \\hypersetup{colorlinks}

                        \\setlength{\\parskip}{1em}

                        \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src
** org-download
#+begin_src emacs-lisp :tangle yes
  (use-package org-download
    :config
    (setq-default org-download-image-dir "./pictures")
    (setq-default org-download-heading-lvl nil)
    (require 'org-download))
#+end_src
** Handling my book collection (deprecated)
*** jethro/org-sort-books
I like to keep my books in sorted order, alphanumerically, and then by TODO keyword.
#+begin_src emacs-lisp :tangle yes
  (defun jethro/org-sort-books ()
      (interactive)
      (let ((old-point (point)))
        (beginning-of-buffer)
        (org-sort-entries t ?a)
        (beginning-of-buffer)
        (org-sort-entries t ?o)
        (show-all)
        (org-global-cycle)
        (goto-char old-point)))
#+end_src
*** jethro/org-after-save-books
#+begin_src emacs-lisp :tangle yes
  (defun jethro/org-after-save-books ()
    (org-publish "books"))
#+end_src
** deft
Deft is similar in many ways to Notational Velocity. I use deft as a brain dump, to quickly collect things I learn or come across.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package deft
    :bind* (("C-c d" . deft)
            ("C-x C-g" . deft-find-file)) 
    :bind (("C-c C-r" . deft-rename-file))
    :config
    (setq deft-directory "~/.org/deft/"
          deft-extensions '("org")
          deft-use-filename-as-title t
          deft-default-extension "org"
          deft-use-filter-string-for-filename t
          deft-file-naming-rules '((noslash . "_")
                                   (nospace . "_")
                                   (case-fn . downcase))))

#+END_SRC
** epresent
#+begin_src emacs-lisp :tangle yes
  (use-package epresent
    :bind ("<f5>"))
#+end_src
* Project Management
** Smerge-mode
Useful when handling git merge conflicts.
#+begin_src emacs-lisp :tangle yes
  (use-package smerge-mode
    :functions smerge-next smerge-prev smerge-keep-all smerge-keep-mine smerge-keep-other
    :config
    (progn
      (global-set-key (kbd "C-c s")
                      (defhydra hydra-smerge (:body-pre (smerge-mode 1) :color red)
                        "Smerge mode"
                        ("<down>" smerge-next        "Next conflict")
                        ("<up>"   smerge-prev        "Previous conflict")
                        ("M-a"    smerge-keep-all    "Keep all")
                        ("M-m"    smerge-keep-mine   "Keep mine")
                        ("M-o"    smerge-keep-other  "Keep other")))))
#+end_src
** Magit
#+begin_src emacs-lisp :tangle yes
  (use-package magit  
    :bind (("s-g" . magit-status)
           ("s-G" . magit-blame))
    :init (setq magit-auto-revert-mode nil)
    :config
    ;; (use-package magithub)
    (add-hook 'magit-mode-hook 'hl-line-mode))
#+end_src

** Projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :demand t
    :init (projectile-global-mode 1)
    :bind-keymap* ("C-x p" . projectile-command-map)
    :config
    (require 'projectile)
    (use-package counsel-projectile 
      :bind (("s-f" . counsel-projectile-find-file)
             ("s-b" . counsel-projectile-switch-to-buffer))
      :config
      (counsel-projectile-on))
    (setq projectile-use-git-grep t)
    (setq projectile-create-missing-test-files t)
    (setq projectile-completion-system 'ivy))
#+end_src

*** Projectile Commander
#+begin_src emacs-lisp :tangle yes
  (setq projectile-switch-project-action
        #'projectile-commander)
  (def-projectile-commander-method ?s
    "Open a *eshell* buffer for the project."
    (projectile-run-eshell))
  (def-projectile-commander-method ?c
    "Run `compile' in the project."
    (projectile-compile-project nil))
  (def-projectile-commander-method ?\C-?
    "Go back to project selection."
    (projectile-switch-project))
  (def-projectile-commander-method ?d
    "Open project root in dired."
    (projectile-dired))
  (def-projectile-commander-method ?F
    "Git fetch."
    (magit-status)
    (call-interactively #'magit-fetch-all))
  (def-projectile-commander-method ?j
    "Jack-in."
    (let* ((opts (projectile-current-project-files))
           (file (ivy-read
                  "Find file: " 
                  opts)))
      (find-file (expand-file-name
                  file (projectile-project-root)))
      (run-hooks 'projectile-find-file-hook)
      (cider-jack-in)))
#+end_src
* Profiling
** esup
#+begin_src emacs-lisp :tangle yes
(use-package esup
  :defer t)
#+end_src
** keyfreq
#+begin_src emacs-lisp :tangle yes
(use-package keyfreq
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+end_src
* Miscellaneous
** Pivotal-mode
#+begin_src emacs-lisp :tangle no
  (use-package pivotal-tracker
    :config
    (setq pivotal-api-token jethro/pivotal-api-token))
#+end_src
** which-key
#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :diminish which-key-mode
  :config (add-hook 'after-init-hook 'which-key-mode))
#+end_src
** nameless
#+begin_src emacs-lisp :tangle yes
(use-package nameless
  :diminish nameless-mode
  :config
  (add-hook 'emacs-lisp-mode-hook 'nameless-mode-from-hook)
  (setq nameless-global-aliases
        '(("fl" . "font-lock")
          ("s" . "seq")
          ("me" . "macroexp")
          ("c" . "cider")
          ("q" . "queue"))))
#+end_src
** firestarter
#+begin_src emacs-lisp :tangle yes
(use-package firestarter
  :bind ("C-c M s" . firestarter-mode)
  :init (put 'firestarter 'safe-local-variable 'identity))
#+end_src
** Paradox
Use Paradox instead of the default =package-list-packages=. =jethro/paradox-user-token= is defined in =secrets.el=, and contains a github API token which has =public_repo= permissions.
#+begin_src emacs-lisp :tangle yes
(use-package paradox
  :commands (paradox-list-packages)
  :config
  (setq paradox-github-token jethro/paradox-user-token))
#+end_src
** focus
#+begin_src emacs-lisp :tangle yes
(use-package focus
  :diminish focus-mode
  :bind ("C-c M f" . focus-mode))
#+end_src
** artbollocks
Prevent usage of passive voice, weasel words and other common grammatical mistakes.
#+begin_src emacs-lisp :tangle yes
(use-package artbollocks-mode
  :bind (("C-c M a" . artbollocks-mode))
  :config
  (add-hook 'text-mode-hook 'artbollocks-mode))
#+end_src
** darkroom
#+begin_src emacs-lisp :tangle yes
(use-package darkroom
  :bind (("C-c M d" . darkroom-mode)
         ("C-c M t" . darkroom-tentative-mode)))
#+end_src
** bury-successful-compilation
Closes compile buffer if there are no errors.
#+begin_src emacs-lisp :tangle yes
(use-package bury-successful-compilation
  :config
  (bury-successful-compilation 1))
#+end_src
* Tangling                                                         :noexport:
#+begin_src emacs-lisp :tangle no
  (org-babel-tangle)
#+end_src
